<#

https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/
#>

#Requires -Version 3

# ----------------------------------------------------------------
# Helpers 
# ----------------------------------------------------------------
#region Helpers 
$GlobalIndentLevel = 0

$GlobalIgnoredPrograms = @("Common Files", "Internet Explorer", "ModifiableWindowsApps", "VMware", "Windows Defender", "Windows Defender Advanced Threat Protection", "Windows Mail", "Windows Media Player", "Windows Multimedia Platform", "Windows NT", "Windows Photo Viewer", "Windows Portable Devices", "Windows Security", "WindowsPowerShell", "Microsoft.NET", "Windows Portable Devices", "dotnet", "MSBuild", "Intel", "Reference Assemblies")

$GlobalIgnoredServices = @("1394ohci", "3ware", "AarSvc", "ACPI", "AcpiDev", "acpiex", "acpipagr", "AcpiPmi", "acpitime", "Acx01000", "ADOVMPPackage", "ADP80XX", "adsi", "AFD", "afunix", "ahcache", "AJRouter", "ALG", "amdgpio2", "amdi2c", "AmdK8", "AmdPPM", "amdsata", "amdsbs", "amdxata", "AppID", "AppIDSvc", "Appinfo", "applockerfltr", "AppMgmt", "AppReadiness", "AppVClient", "AppvStrm", "AppvVemgr", "AppvVfs", "AppXSvc", "arcsas", "AssignedAccessManagerSvc", "AsyncMac", "atapi", "AudioEndpointBuilder", "Audiosrv", "autotimesvc", "AxInstSV", "b06bdrv", "bam", "BasicDisplay", "BasicRender", "BattC", "BcastDVRUserService", "bcmfn2", "BDESVC", "Beep", "BFE", "bindflt", "BITS", "BluetoothUserService", "bowser", "BrokerInfrastructure", "Browser", "BTAGService", "BthA2dp", "BthAvctpSvc", "BthEnum", "BthHFEnum", "BthLEEnum", "BthMini", "BTHMODEM", "BthPan", "BTHPORT", "bthserv", "BTHUSB", "bttflt", "buttonconverter", "CAD", "camsvc", "CaptureService", "cbdhsvc", "cdfs", "CDPSvc", "CDPUserSvc", "cdrom", "CertPropSvc", "cht4iscsi", "cht4vbd", "CimFS", "circlass", "CldFlt", "CLFS", "ClipSVC", "clr_optimization_v4.0.30319_32", "clr_optimization_v4.0.30319_64", "CmBatt", "CNG", "cnghwassist", "CompositeBus", "COMSysApp", "condrv", "ConsentUxUserSvc", "CoreMessagingRegistrar", "CoreUI", "CredentialEnrollmentManagerUserSvc", "crypt32", "CryptSvc", "CSC", "CscService", "dam", "DCLocator", "DcomLaunch", "defragsvc", "DeviceAssociationBrokerSvc", "DeviceAssociationService", "DeviceInstall", "DevicePickerUserSvc", "DevicesFlowUserSvc", "DevQueryBroker", "Dfsc", "Dhcp", "diagnosticshub.standardcollector.service", "diagsvc", "DiagTrack", "disk", "DispBrokerDesktopSvc", "DisplayEnhancementService", "DmEnrollmentSvc", "dmvsc", "dmwappushservice", "Dnscache", "DoSvc", "dot3svc", "DPS", "drmkaud", "DsmSvc", "DsSvc", "DusmSvc", "DXGKrnl", "e1i65x64", "Eaphost", "ebdrv", "EFS", "EhStorClass", "EhStorTcgDrv", "embeddedmode", "EntAppSvc", "ErrDev", "ESENT", "EventLog", "EventSystem", "exfat", "fastfat", "Fax", "fdc", "fdPHost", "FDResPub", "fhsvc", "FileCrypt", "FileInfo", "Filetrace", "flpydisk", "FltMgr", "FontCache", "FrameServer", "FsDepends", "Fs_Rec", "fvevol", "gencounter", "genericusbfn", "GPIOClx0101", "gpsvc", "GpuEnergyDrv", "GraphicsPerfSvc", "HdAudAddService", "HDAudBus", "HidBatt", "HidBth", "hidi2c", "hidinterrupt", "HidIr", "hidserv", "hidspi", "HidUsb", "HomeGroupListener", "HomeGroupProvider", "HpSAMD", "HTTP", "hvcrash", "HvHost", "hvservice", "HwNClx0101", "hwpolicy", "hyperkbd", "HyperVideo", "i8042prt", "iagpio", "iai2c", "iaLPSS2i_GPIO2", "iaLPSS2i_GPIO2_BXT_P", "iaLPSS2i_GPIO2_CNL", "iaLPSS2i_GPIO2_GLK", "iaLPSS2i_I2C", "iaLPSS2i_I2C_BXT_P", "iaLPSS2i_I2C_CNL", "iaLPSS2i_I2C_GLK", "iaLPSSi_GPIO", "iaLPSSi_I2C", "iaStorAV", "iaStorAVC", "iaStorV", "ibbus", "icssvc", "IKEEXT", "IndirectKmd", "inetaccs", "InstallService", "intelide", "intelpep", "intelpmax", "intelppm", "iorate", "IpFilterDriver", "iphlpsvc", "IPMIDRV", "IPNAT", "IPT", "IpxlatCfgSvc", "isapnp", "iScsiPrt", "ItSas35i", "kbdclass", "kbdhid", "kdnic", "KeyIso", "KSecDD", "KSecPkg", "ksthunk", "KtmRm", "LanmanServer", "LanmanWorkstation", "ldap", "lfsvc", "LicenseManager", "lltdio", "lltdsvc", "lmhosts", "Lsa", "LSI_SAS", "LSI_SAS2i", "LSI_SAS3i", "LSI_SSS", "LSM", "luafv", "LxpSvc", "MapsBroker", "mausbhost", "mausbip", "MbbCx", "megasas", "megasas2i", "megasas35i", "megasr", "MessagingService", "Microsoft_Bluetooth_AvrcpTransport", "MixedRealityOpenXRSvc", "mlx4_bus", "MMCSS", "Modem", "monitor", "mouclass", "mouhid", "mountmgr", "mpsdrv", "mpssvc", "MRxDAV", "mrxsmb", "mrxsmb20", "MsBridge", "Msfs", "msgpiowin32", "mshidkmdf", "mshidumdf", "msisadrv", "MSiSCSI", "msiserver", "MSKSSRV", "MsLldp", "MSPCLOCK", "MSPQM", "MsQuic", "MsRPC", "MSSCNTRS", "MsSecFlt", "mssmbios", "MSTEE", "MTConfig", "Mup", "mvumis", "napagent", "NativeWifiP", "NaturalAuthentication", "NcaSvc", "NcbService", "NcdAutoSetup", "ndfltr", "NDIS", "NdisCap", "NdisImPlatform", "NdisTapi", "Ndisuio", "NdisVirtualBus", "NdisWan", "ndiswanlegacy", "NDKPing", "ndproxy", "Ndu", "NetAdapterCx", "NetBIOS", "NetbiosSmb", "NetBT", "Netlogon", "Netman", "netprofm", "NetSetupSvc", "NetTcpPortSharing", "netvsc", "NgcCtnrSvc", "NgcSvc", "NlaSvc", "Npfs", "npsvctrig", "nsi", "nsiproxy", "NTDS", "Ntfs", "Null", "nvdimm", "nvraid", "nvstor", "OneSyncSvc", "p2pimsvc", "p2psvc", "Parport", "partmgr", "PcaSvc", "pci", "pciide", "pcmcia", "pcw", "pdc", "PEAUTH", "PeerDistSvc", "perceptionsimulation", "percsas2i", "percsas3i", "PerfDisk", "PerfHost", "PerfNet", "PerfOS", "PerfProc", "PhoneSvc", "PimIndexMaintenanceSvc", "PktMon", "pla", "PlugPlay", "pmem", "PNPMEM", "PNRPAutoReg", "PNRPsvc", "PolicyAgent", "portcfg", "PortProxy", "Power", "PptpMiniport", "PrintNotify", "PrintWorkflowUserSvc", "Processor", "ProfSvc", "Psched", "PushToInstall", "pvscsi", "QWAVE", "QWAVEdrv", "Ramdisk", "RasAcd", "RasAgileVpn", "RasAuto", "Rasl2tp", "RasMan", "RasPppoe", "RasSstp", "rdbss", "RDMANDK", "rdpbus", "RDPDR", "RDPNP", "RDPUDD", "RdpVideoMiniport", "rdyboost", "ReFS", "ReFSv1", "RemoteAccess", "RemoteRegistry", "RetailDemo", "RFCOMM", "rhproxy", "RmSvc", "RpcEptMapper", "RpcLocator", "RpcSs", "rspndr", "s3cap", "SamSs", "sbp2port", "SCardSvr", "ScDeviceEnum", "scfilter", "Schedule", "scmbus", "SCPolicySvc", "sdbus", "SDFRd", "SDRSVC", "sdstor", "seclogon", "SecurityHealthService", "SEMgrSvc", "SENS", "Sense", "SensorDataService", "SensorService", "SensrSvc", "SerCx", "SerCx2", "Serenum", "Serial", "sermouse", "SessionEnv", "sfloppy", "SgrmAgent", "SgrmBroker", "SharedAccess", "SharedRealitySvc", "ShellHWDetection", "shpamsvc", "SiSRaid2", "SiSRaid4", "SmartSAMD", "smbdirect", "smphost", "SmsRouter", "SMSvcHost 4.0.0.0", "SNMPTRAP", "spaceparser", "spaceport", "SpatialGraphFilter", "SpbCx", "spectrum", "Spooler", "sppsvc", "srv2", "srvnet", "SSDPSRV", "ssh-agent", "SstpSvc", "StateRepository", "stexstor", "stisvc", "storahci", "storflt", "stornvme", "storqosflt", "StorSvc", "storufs", "storvsc", "svsvc", "swenum", "swprv", "Synth3dVsc", "SysMain", "SystemEventsBroker", "TabletInputService", "TapiSrv", "Tcpip", "Tcpip6", "TCPIP6TUNNEL", "tcpipreg", "TCPIPTUNNEL", "tdx", "Telemetry", "terminpt", "TermService", "Themes", "TieringEngineService", "TimeBrokerSvc", "TokenBroker", "TPM", "TrkWks", "TroubleshootingSvc", "TrustedInstaller", "TSDDD", "TsUsbFlt", "TsUsbGD", "tsusbhub", "tunnel", "tzautoupdate", "UASPStor", "UcmCx0101", "UcmTcpciCx0101", "UcmUcsiAcpiClient", "UcmUcsiCx0101", "Ucx01000", "UdeCx", "udfs", "UdkUserSvc", "UEFI", "UevAgentDriver", "UevAgentService", "Ufx01000", "UfxChipidea", "ufxsynopsys", "UGatherer", "UGTHRSVC", "umbus", "UmPass", "UmRdpService", "UnistoreSvc", "upnphost", "UrsChipidea", "UrsCx01000", "UrsSynopsys", "usbaudio", "usbaudio2", "usbccgp", "usbcir", "usbehci", "usbhub", "USBHUB3", "usbohci", "usbprint", "usbser", "USBSTOR", "usbuhci", "USBXHCI", "UserDataSvc", "UserManager", "UsoSvc", "VacSvc", "VaultSvc", "vdrvroot", "vds", "VerifierExt", "VGAuthService", "vhdmp", "vhf", "Vid", "VirtualRender", "vm3dmp", "vm3dmp-debug", "vm3dmp-stats", "vm3dmp_loader", "vmbus", "VMBusHID", "vmci", "vmgid", "vmhgfs", "vmicguestinterface", "vmicheartbeat", "vmickvpexchange", "vmicrdv", "vmicshutdown", "vmictimesync", "vmicvmsession", "vmicvss", "VMMemCtl", "vmmouse", "vmrawdsk", "vmusbmouse", "vmvss", "vmwefifw", "vmxnet3ndis6", "volmgr", "volmgrx", "volsnap", "volume", "vpci", "vsmraid", "vsock", "VSS", "VSTXRAID", "vwifibus", "vwififlt", "W32Time", "WaaSMedicSvc", "WacomPen", "WalletService", "wanarp", "wanarpv6", "WarpJITSvc", "wbengine", "WbioSrvc", "wcifs", "Wcmsvc", "wcncsvc", "wcnfs", "WdBoot", "Wdf01000", "WdFilter", "WdiServiceHost", "WdiSystemHost", "wdiwifi", "WdmCompanionFilter", "WdNisDrv", "WdNisSvc", "WebClient", "Wecsvc", "WEPHOSTSVC", "wercplsupport", "WerSvc", "WFDSConMgrSvc", "WFPLWFS", "WiaRpc", "WIMMount", "WinDefend", "Windows Workflow Foundation 4.0.0.0", "WindowsTrustedRT", "WindowsTrustedRTProxy", "WinHttpAutoProxySvc", "WinMad", "Winmgmt", "WinNat", "WinRM", "Winsock", "WinSock2", "WINUSB", "WinVerbs", "wisvc", "WlanSvc", "wlidsvc", "wlpasvc", "WManSvc", "WmiAcpi", "WmiApRpl", "wmiApSrv", "WMPNetworkSvc", "Wof", "workerdd", "workfolderssvc", "WpcMonSvc", "WPDBusEnum", "WpdUpFltr", "WpnService", "WpnUserService", "ws2ifsl", "wscsvc", "WSearch", "WSearchIdxPi", "wuauserv", "WudfPf", "WUDFRd", "WwanSvc", "XblAuthManager", "XblGameSave", "xboxgip", "XboxGipSvc", "XboxNetApiSvc", "xinputhid", "xmlprov")

function Write-Message {
    [CmdletBinding()] param(
        [String]
        $Message,
        [ValidateSet("Success", "Info", "Warning", "Error")][String]
        $Level
    )

    For ($i = 0; $i -lt $GlobalIndentLevel; $i++) {
        Write-Host -NoNewLine "    "
    }

    if ($Level -eq "Success") {
        Write-Host -ForegroundColor Green -NoNewline "[+] "
    } elseif ($Level -eq "Info") {
        Write-Host -ForegroundColor Blue -NoNewline "[*] "
    } elseif ($Level -eq "Warning") {
        Write-Host -ForegroundColor Yellow -NoNewline "[!] "
    } elseif ($Level -eq "Error") {
        Write-Host -ForegroundColor Red -NoNewline "[-] "
    } 

    Write-Host $Message
}

function Convert-DateToString {
    [CmdletBinding()] param(
        [System.DateTime]
        $Date
    )

    return $Date.ToString('yyyy-MM-dd - HH:mm:ss')
}

function Convert-ServiceTypeToString {
    [CmdletBinding()] param(
        [int]
        $ServiceType
    )

    $Result = ""

    if ($ServiceType -eq 1) {
        $Result = "KernelDriver"
    } elseif ($ServiceType -eq 2) {
        $Result = "FileSystemDriver"
    } elseif ($ServiceType -eq 4) {
        $Result = "Adapter"
    } elseif ($ServiceType -eq 8) {
        $Result = "RecognizerDriver"
    } elseif ($ServiceType -eq 16) {
        $Result = "Win32OwnProcess"
    } elseif ($ServiceType -eq 32) {
        $Result = "Win32ShareProcess"
    } elseif ($ServiceType -eq 256) {
        $Result = "InteractiveProcess"
    } else {
        $Result = "Unknown"
    }

    return $Result
}

function Convert-ServiceStartModeToString {
    [CmdletBinding()] param(
        [int]
        $StartMode
    )

    $Result = ""

    if ($StartMode -eq 0) {
        $Result = "Boot"
    } elseif ($StartMode -eq 1) {
        $Result = "System"
    } elseif ($StartMode -eq 2) {
        $Result = "Automatic"
    } elseif ($StartMode -eq 3) {
        $Result = "Manual"
    } elseif ($StartMode -eq 4) {
        $Result = "Disabled"
    } else {
        $Result = "Unknown"
    }

    return $Result
}

function Get-InstalledPrograms {
    [CmdletBinding()] param(
        [switch]
        $Filtered = $False
    )

    $InstalledProgramsResult = New-Object System.Collections.ArrayList

    $InstalledPrograms = New-Object System.Collections.ArrayList

    $PathProgram32 = Join-Path -Path $env:SystemDrive -ChildPath "Program Files (x86)"
    $PathProgram64 = Join-Path -Path $env:SystemDrive -ChildPath "Program Files" 

    [void]$InstalledPrograms.AddRange($(Get-ChildItem -Path $PathProgram32,$PathProgram64 -ErrorAction SilentlyContinue))
    
    $RegInstalledPrograms = Get-ChildItem -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"
    ForEach ($InstalledProgram in $RegInstalledPrograms) {
        $InstallLocation = [System.Environment]::ExpandEnvironmentVariables($InstalledProgram.GetValue("InstallLocation"))
        if ($InstallLocation) {
            if (Test-Path -Path $InstallLocation) {
                if ($InstallLocation[$InstallLocation.Length - 1] -eq "\") {
                    $InstallLocation = $InstallLocation.SubString(0, $InstallLocation.Length - 1)
                }
                $FileObject = Get-Item -Path $InstallLocation -ErrorAction SilentlyContinue -ErrorVariable GetItemError 
                if ($GetItemError) {
                    continue 
                }
                if ($FileObject -is [System.IO.DirectoryInfo]) {
                    continue
                }
                [void]$InstalledPrograms.Add([object]$FileObject)
            }
        }
    }

    $PathListResult = New-Object System.Collections.ArrayList
    ForEach ($InstalledProgram in $InstalledPrograms) {
        if (-not ($PathListResult -contains $InstalledProgram.FullName)) {
            [void]$InstalledProgramsResult.Add($InstalledProgram)
            [void]$PathListResult.Add($InstalledProgram.FullName)
        }
    }

    if ($Filtered) {
        $InstalledProgramsResultFiltered = New-Object -TypeName System.Collections.ArrayList
        ForEach ($InstalledProgram in $InstalledProgramsResult) {
            if (-Not ($GlobalIgnoredPrograms -contains $InstalledProgram.Name)) {
                if (-Not (($InstalledProgram.Name -Like "Windows*") -Or ($InstalledProgram.Name -Like "Microsoft*"))) {
                    [void]$InstalledProgramsResultFiltered.Add($InstalledProgram)
                }
            }
        }
        return $InstalledProgramsResultFiltered
    }
    
    return $InstalledProgramsResult
}

function Get-ServiceList {
    [CmdletBinding()] param(
        [switch]
        $Filtered = $False 
    )

    $ServiceListResult = New-Object -TypeName System.Collections.ArrayList

    $RegAllServices = Get-ChildItem -path "Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services" 

    $KnownServices = @("AarSvc_*", "BcastDVRUserService_*", "BluetoothUserService_*", "CaptureService_*", "cbdhsvc_*", "CDPUserSvc_*", "clr_optimization_*", "ConsentUxUserSvc_*", "CredentialEnrollmentManagerUserSvc_*", "DeviceAssociationBrokerSvc_*", "DevicePickerUserSvc_*", "DevicesFlowUserSvc_*", "FontCache*", "IpOverUsbSvc", "MessagingService_*", "MSDTC*", ".NET*", "OneSyncSvc_*", "PimIndexMaintenanceSvc_*", "PrintWorkflowUserSvc_*", "UnistoreSvc_*", "UserDataSvc_*", "WpnUserService_*")

    ForEach ($RegService in $RegAllServices) {
        
        $ServiceListItem = New-Object -TypeName PSOBject 
        $ServiceListItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $RegService.PSChildName 
        $ServiceListItem | Add-Member -MemberType "NoteProperty" -Name "RegistryKey" -Value $RegService.Name
        $ServiceListItem | Add-Member -MemberType "NoteProperty" -Name "RegistryPath" -Value $RegService.PSPath 

        if ($Filtered) {
            $ServiceName = $RegService.PSChildName 
            # Exclude standard Windows services 
            if (-not ($GlobalIgnoredServices -contains $ServiceName)) {
                # Exclude known services 
                $IsKnownSerice = $False
                ForEach ($KnownService in $KnownServices) {
                    if ($ServiceName -like $KnownService) {
                        $IsKnownSerice = $True 
                        break
                    }
                }
                if (-not $IsKnownSerice) {

                    $ServiceProperties = Get-ItemProperty -Path $RegService.PSPath -ErrorAction SilentlyContinue -ErrorVariable GetItemPropertyError
                    if (-not $GetItemPropertyError) {
                        # Exlcude empty ImagePath
                        if ($ServiceProperties.ImagePath) {
                            # Include only these service types: Win32OwnProcess(16), Win32ShareProcess(32), InteractiveProcess(256)
                            # i.e. Exclude these services types: KernelDriver(1), FileSystemDriver(2), Adapter(4), RecognizerDriver(8)
                            if ($ServiceProperties.Type -ge 16) {
                                [void]$ServiceListResult.Add($ServiceListItem) 
                            }
                        } 
                    } 
                }
            }
        } else {
            [void]$ServiceListResult.Add($ServiceListItem) 
        }
    }

    return $ServiceListResult
}

function Get-ModifiablePath {
    <#
        .SYNOPSIS
    
            Parses a passed string containing multiple possible file/folder paths and returns
            the file paths where the current user has modification rights.
    
            Author: @harmj0y
            License: BSD 3-Clause
    
        .DESCRIPTION
    
            Takes a complex path specification of an initial file/folder path with possible
            configuration files, 'tokenizes' the string in a number of possible ways, and
            enumerates the ACLs for each path that currently exists on the system. Any path that
            the current user has modification rights on is returned in a custom object that contains
            the modifiable path, associated permission set, and the IdentityReference with the specified
            rights. The SID of the current user and any group he/she are a part of are used as the
            comparison set against the parsed path DACLs.
    
        .PARAMETER Path
    
            The string path to parse for modifiable files. Required
    
        .PARAMETER LiteralPaths
    
            Switch. Treat all paths as literal (i.e. don't do 'tokenization').
    
        .EXAMPLE
    
            PS C:\> '"C:\Temp\blah.exe" -f "C:\Temp\config.ini"' | Get-ModifiablePath
    
            Path                       Permissions                IdentityReference
            ----                       -----------                -----------------
            C:\Temp\blah.exe           {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
            C:\Temp\config.ini         {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
    
        .EXAMPLE
    
            PS C:\> Get-ChildItem C:\Vuln\ -Recurse | Get-ModifiablePath
    
            Path                       Permissions                IdentityReference
            ----                       -----------                -----------------
            C:\Vuln\blah.bat           {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
            C:\Vuln\config.ini         {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
            ...
    #>
    
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$True)]
        [Alias('FullName')]
        [String[]]
        $Path,

        [Switch]
        $LiteralPaths
    )

    BEGIN {
        # # false positives ?
        # $Excludes = @("MsMpEng.exe", "NisSrv.exe")

        # from http://stackoverflow.com/questions/28029872/retrieving-security-descriptor-and-getting-number-for-filesystemrights
        $AccessMask = @{
            [uint32]'0x80000000' = 'GenericRead'
            [uint32]'0x40000000' = 'GenericWrite'
            [uint32]'0x20000000' = 'GenericExecute'
            [uint32]'0x10000000' = 'GenericAll'
            [uint32]'0x02000000' = 'MaximumAllowed'
            [uint32]'0x01000000' = 'AccessSystemSecurity'
            [uint32]'0x00100000' = 'Synchronize'
            [uint32]'0x00080000' = 'WriteOwner'
            [uint32]'0x00040000' = 'WriteDAC'
            [uint32]'0x00020000' = 'ReadControl'
            [uint32]'0x00010000' = 'Delete'
            [uint32]'0x00000100' = 'WriteAttributes'
            [uint32]'0x00000080' = 'ReadAttributes'
            [uint32]'0x00000040' = 'DeleteChild'
            [uint32]'0x00000020' = 'Execute/Traverse'
            [uint32]'0x00000010' = 'WriteExtendedAttributes'
            [uint32]'0x00000008' = 'ReadExtendedAttributes'
            [uint32]'0x00000004' = 'AppendData/AddSubdirectory'
            [uint32]'0x00000002' = 'WriteData/AddFile'
            [uint32]'0x00000001' = 'ReadData/ListDirectory'
        }

        $UserIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
        $CurrentUserSids = $UserIdentity.Groups | Select-Object -ExpandProperty Value
        $CurrentUserSids += $UserIdentity.User.Value

        $TranslatedIdentityReferences = @{}
    }

    PROCESS {

        ForEach($TargetPath in $Path) {

            $CandidatePaths = @()

            # possible separator character combinations
            $SeparationCharacterSets = @('"', "'", ' ', "`"'", '" ', "' ", "`"' ")

            if($PSBoundParameters['LiteralPaths']) {

                $TempPath = $([System.Environment]::ExpandEnvironmentVariables($TargetPath))

                if(Test-Path -Path $TempPath -ErrorAction SilentlyContinue) {
                    $CandidatePaths += Resolve-Path -Path $TempPath | Select-Object -ExpandProperty Path
                }
                else {
                    # if the path doesn't exist, check if the parent folder allows for modification
                    try {
                        $ParentPath = Split-Path $TempPath -Parent
                        if($ParentPath -and (Test-Path -Path $ParentPath)) {
                            $CandidatePaths += Resolve-Path -Path $ParentPath -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path
                        }
                    }
                    catch {
                        # because Split-Path doesn't handle -ErrorAction SilentlyContinue nicely
                    }
                }
            }
            else {
                ForEach($SeparationCharacterSet in $SeparationCharacterSets) {
                    $TargetPath.Split($SeparationCharacterSet) | Where-Object {$_ -and ($_.trim() -ne '')} | ForEach-Object {

                        if(($SeparationCharacterSet -notmatch ' ')) {

                            $TempPath = $([System.Environment]::ExpandEnvironmentVariables($_)).Trim()

                            if($TempPath -and ($TempPath -ne '')) {
                                if(Test-Path -Path $TempPath -ErrorAction SilentlyContinue) {
                                    # if the path exists, resolve it and add it to the candidate list
                                    $CandidatePaths += Resolve-Path -Path $TempPath | Select-Object -ExpandProperty Path
                                }

                                else {
                                    # if the path doesn't exist, check if the parent folder allows for modification
                                    try {
                                        $ParentPath = (Split-Path -Path $TempPath -Parent).Trim()
                                        if($ParentPath -and ($ParentPath -ne '') -and (Test-Path -Path $ParentPath )) {
                                            $CandidatePaths += Resolve-Path -Path $ParentPath | Select-Object -ExpandProperty Path
                                        }
                                    }
                                    catch {
                                        # trap because Split-Path doesn't handle -ErrorAction SilentlyContinue nicely
                                    }
                                }
                            }
                        }
                        else {
                            # if the separator contains a space
                            $CandidatePaths += Resolve-Path -Path $([System.Environment]::ExpandEnvironmentVariables($_)) -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path | ForEach-Object {$_.Trim()} | Where-Object {($_ -ne '') -and (Test-Path -Path $_)}
                        }
                    }
                }
            }

            $CandidatePaths | Sort-Object -Unique | ForEach-Object {
                $CandidatePath = $_
                Get-Acl -Path $CandidatePath | Select-Object -ExpandProperty Access | Where-Object {($_.AccessControlType -match 'Allow')} | ForEach-Object {

                    $FileSystemRights = $_.FileSystemRights.value__

                    $Permissions = $AccessMask.Keys | Where-Object { $FileSystemRights -band $_ } | ForEach-Object { $accessMask[$_] }

                    # the set of permission types that allow for modification
                    $Comparison = Compare-Object -ReferenceObject $Permissions -DifferenceObject @('GenericWrite', 'GenericAll', 'MaximumAllowed', 'WriteOwner', 'WriteDAC', 'WriteData/AddFile', 'AppendData/AddSubdirectory') -IncludeEqual -ExcludeDifferent

                    if($Comparison) {
                        if ($_.IdentityReference -notmatch '^S-1-5.*' -and $_.IdentityReference -notmatch '^S-1-15-.*') {
                            if(-not ($TranslatedIdentityReferences[$_.IdentityReference])) {
                                # translate the IdentityReference if it's a username and not a SID
                                $IdentityUser = New-Object System.Security.Principal.NTAccount($_.IdentityReference)
                                $TranslatedIdentityReferences[$_.IdentityReference] = $IdentityUser.Translate([System.Security.Principal.SecurityIdentifier]) | Select-Object -ExpandProperty Value
                            }
                            $IdentitySID = $TranslatedIdentityReferences[$_.IdentityReference]
                        }
                        else {
                            $IdentitySID = $_.IdentityReference
                        }

                        if($CurrentUserSids -contains $IdentitySID) {
                            New-Object -TypeName PSObject -Property @{
                                ModifiablePath = $CandidatePath
                                IdentityReference = $_.IdentityReference
                                Permissions = $Permissions
                            }
                        }
                    }
                }
            }
        }
    }
}
#endregion Helpers 


# ----------------------------------------------------------------
# Checks  
# ----------------------------------------------------------------
#region Checks 
# ----------------------------------------------------------------
# BEGIN MISC   
# ----------------------------------------------------------------
function Invoke-SystemInfoCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    https://techthoughts.info/windows-version-numbers/
    #>
    
    [CmdletBinding()] param()

    $Item = Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion" 

    $SystemInfoResult = New-Object -TypeName PSObject 

    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "ProductName" -Value $Item.ProductName
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Major" -Value $Item.CurrentMajorVersionNumber
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Minor" -Value $Item.CurrentMinorVersionNumber
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Release" -Value $Item.ReleaseId
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Build" -Value $Item.CurrentBuild
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Revision" -Value $Item.UBR

    $FullVersion = "$($Item.CurrentMajorVersionNumber).$($Item.CurrentMinorVersionNumber).$($Item.CurrentBuild) Version $($Item.ReleaseId) ($($Item.CurrentBuild).$($Item.UBR))"

    Write-Message -Level Info "OS Name: $($Item.ProductName)"
    Write-Message -Level Info "OS Version: $($FullVersion)"
    
    return $SystemInfoResult
}

function Invoke-SystemStartupHistoryCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .PARAMETER TimeSpanInDays
    Parameter description
    
    .EXAMPLE
    An example
    
    .NOTES
    Event ID 6005: The Event log service was started, i.e. system startup theoretically.
    #>
    
    [CmdletBinding()] param(
        [int]
        $TimeSpanInDays = 31
    )

    $SystemStartupHistoryResult = New-Object -TypeName "PSObject" 
    $SystemStartupHistoryResult | Add-Member -MemberType "NoteProperty" -Name "Name" -Value "SystemStartupHistoryCheck"

    $StartDate = (Get-Date).AddDays(-$TimeSpanInDays)
    $EndDate = Get-Date

    $TimeSpan = New-TimeSpan -Start $StartDate -End $EndDate
    $SystemStartupHistoryResult | Add-Member -MemberType "NoteProperty" -Name "Timespan in days" -Value $TimeSpan.Days

    $StartupEvents = Get-EventLog -LogName "System" -EntryType "Information" -After $StartDate -Before $EndDate | Where-Object {$_.EventID -eq 6005}
    $SystemStartupHistoryResult | Add-Member -MemberType "NoteProperty" -Name "Number of startup events" -Value $StartupEvents.Length

    Write-Message -Level Info "Found $($StartupEvents.Length) startup events in the last $($TimeSpan.Days) days."

    if ($StartupEvents.Length -gt 0) {
        $SystemStartupHistoryResult | Add-Member -MemberType "NoteProperty" -Name "Last startup time" -Value "$(Convert-DateToString -Date $StartupEvents[0].TimeGenerated)"
        Write-Message -Level Info "Last startup time was: $(Convert-DateToString -Date $StartupEvents[0].TimeGenerated)"

        if ($StartupEvents.Length -gt 10) {
            Write-Message -Level Success "The machine seems to be frequently rebooted. Showing last 10 events."
            For ($i = 0; $i -lt 10; $i++) {
                $GlobalIndentLevel +=1
                Write-Message -Level Info "Startup event: $(Convert-DateToString -Date $StartupEvents[$i].TimeGenerated)"
                $GlobalIndentLevel -=1
            }
        }
    } else {
        $LastStartupTime = (Get-EventLog -LogName "System" -EntryType "Information" -Newest 1 -InstanceId 2147489653).TimeGenerated
        $SystemStartupHistoryResult | Add-Member -MemberType "NoteProperty" -Name "Last startup time" -Value "$(Convert-DateToString -Date $LastStartupTime)"
        Write-Message -Level Warning "Last startup time was: $(Convert-DateToString -Date $LastStartupTime)."
    }

    return $SystemStartupHistoryResult
}

function Invoke-SystemDrivesCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    General notes
    #>
    
    [CmdletBinding()] param()

    $Drives = Get-PSDrive -PSProvider "FileSystem"

    Write-Message -Level Info "Found $($Drives.Length) drives."
    ForEach ($Drive in $Drives) {
        $GlobalIndentLevel += 1
        Write-Message -Level Info "$($Drive.Root) - Display name: '$($Drive.DisplayRoot)' - Description: '$($Drive.Description)'"
        $GlobalIndentLevel -= 1
    }

    return $Drives 
}

function Invoke-LocalAdminGroupCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    S-1-5-32-544 = SID of the local admin group 
    S-1-5-21-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxx-500 = SID of the default local admin 
    #>

    [CmdletBinding()] param()

    $LocalAdminGroupResult = New-Object System.Collections.ArrayList 

    $LocalAdminGroup = Get-LocalGroup -SID "S-1-5-32-544" -ErrorAction SilentlyContinue 
    $LocalAdmins = Get-LocalGroupMember -Group $LocalAdminGroup -ErrorAction SilentlyContinue -ErrorVariable GetLocalGroupMemberError

    if (-not $GetLocalGroupMemberError) {
        $GroupClassName = $LocalAdminGroup.ObjectClass 

        Write-Message -Level Info "The local group '$($LocalAdminGroup.Name)' has $($LocalAdmins.Length) members (users/groups)."

        ForEach ($LocalAdmin in $LocalAdmins) {
            $GlobalIndentLevel += 1
            $ItemName = ""
            $ItemType = $LocalAdmin.ObjectClass
            $ItemIsLocal = $True 
            $ItemIsEnabled = $True 
            $LocalAdminGroupResultItem = New-Object -TypeName PSObject
            if  ($LocalAdmin.PrincipalSource -eq "Local") {
                $ItemIsLocal = $True
                if ($LocalAdmin.ObjectClass -eq $GroupClassName) {
                    $LocalGroup = Get-LocalGroup -SID $LocalAdmin.SID 
                    $ItemName = $LocalGroup.Name
                    Write-Message -Level Info "Local group '$($LocalGroup.Name)'."
                } else {
                    $LocalAccount = Get-LocalUser -SID $LocalAdmin.SID 
                    $ItemName = $LocalAccount.Name
                    if ($LocalAccount.Enabled) {
                        $ItemIsEnabled = $True 
                        Write-Message -Level Info "Local user '$($LocalAccount.Name)'."
                    } else {
                        $ItemIsEnabled = $False 
                        Write-Message -Level Warning "Local user '$($LocalAccount.Name)' is disabled."
                    }
                }
            } else {
                $ItemIsLocal = $False
                $ItemName = $LocalAdmin.Name
                if ($LocalAdmin.ObjectClass -eq $GroupClassName) {
                    Write-Message -Level Info "Domain group/user '$($LocalAdmin.Name)'."
                }
            }

            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $ItemName
            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "Type" -Value $ItemType
            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "IsLocal" -Value $ItemIsLocal  
            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "IsEnabled" -Value $ItemIsEnabled 
            [void]$LocalAdminGroupResult.Add($LocalAdminGroupResultItem)

            $GlobalIndentLevel -= 1
        }
    } else {
        Write-Message -Level Error "An unknown error occurred."
        Write-Debug -Message $GetLocalGroupMemberError.Exception 
    }

    return $LocalAdminGroupResult
}

function Invoke-MachineRoleCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    WinNT = workstation
    LanmanNT = domain controller
    ServerNT = server
    #>
    
    [CmdletBinding()] param()

    $MachineRoleResult = New-Object -TypeName PSObject 

    $Item = Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\ProductOptions"
    
    $RoleFriendlyName = ""

    if ($Item.ProductType -eq "WinNT") {
        $RoleFriendlyName = "WorkStation"
    } elseif ($Item.ProducType -eq "LanmanNT") {
        $RoleFriendlyName = "Domain Controller"
    } elseif ($Item.ProductType -eq "ServerNT") {
        $RoleFriendlyName = "Server"
    } else {
        $RoleFriendlyName = "Unknown"
    }

    $MachineRoleResult | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Item.ProductType
    $MachineRoleResult | Add-Member -MemberType "NoteProperty" -Name "Role" -Value $RoleFriendlyName
    Write-Message -Level Info "Machine type: '$($RoleFriendlyName)'"

    return $MachineRoleResult
}

function Invoke-WindowsUpdateCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    General notes
    #>
    
    [CmdletBinding()] param()

    $Results = (New-Object -ComObject "Microsoft.Update.AutoUpdate").Results

    $EndDate = Get-Date 
    $StartDate = $Results.LastInstallationSuccessDate

    $TimeSpan = New-TimeSpan -Start $StartDate -End $EndDate 

    Write-Message -Level Info "Last Installation success: $(Convert-DateToString -Date $Results.LastInstallationSuccessDate)"

    if ($TimeSpan.Months -ge 1) {
        Write-Message -Level Success "Last update occurred more than one month ago."
    }

    return $Results
}
# ----------------------------------------------------------------
# END MISC   
# ----------------------------------------------------------------

# ----------------------------------------------------------------
# BEGIN PRIVILEGES   
# ----------------------------------------------------------------
function Invoke-UserPrivilegesCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    TODO: Rewrite this to avoid a call to an external tool 
    TODO: Add a description on how to exploit each priv 

    Interesting privileges 
        - SeAssignPrimaryTokenPrivilege
        - SeImpersonatePrivilege
        - SeCreateTokenPrivilege
        - SeDebugPrivilege
        - SeLoadDriverPrivilege
        - SeRestorePrivilege
        - SeTakeOwnershipPrivilege
    #>

    [CmdletBinding()] param()

    $UserPrivilegesResult = New-Object -TypeName PSObject 

    $Privileges = "SeAssignPrimaryTokenPrivilege", "SeImpersonatePrivilege", "SeCreateTokenPrivilege", "SeDebugPrivilege", "SeLoadDriverPrivilege", "SeRestorePrivilege", "SeTakeOwnershipPrivilege", "SeShutdownPrivilege"

    #Start-Process -FilePath "whoami.exe" -ArgumentList "/priv" -Wait 
    $Output = (& whoami /priv | Out-String) 
    
    $ArrayOfPrivileges = New-Object System.Collections.ArrayList
    
    $NumberOfPrivs = 0
    $Lines = $Output.Split("`n")
    ForEach ($Line in $Lines) {
        If ($Line -Like "*Se*Privilege*") {
            $NumberOfPrivs += 1
            $Priv = $Line.Split(' ')[0]
            if ($Privileges -contains $Priv) {
                [void]$ArrayOfPrivileges.Add($Priv)
            }
        }
    }

    Write-Message -Level Info "Current user has $($NumberOfPrivs) privileges."
    
    $GlobalIndentLevel += 1
    if ($ArrayOfPrivileges.Length -gt 0) {
        ForEach ($Priv in $ArrayOfPrivileges) {
            Write-Message -Level Success "User has '$Priv' privilege."
            $UserPrivilegesResult | Add-Member -MemberType "NoteProperty" -Name "Privilege" -Value "$Priv"
        }
    } else {
        Write-Message -Level Info "No interesting privilege found."
    }
    $GlobalIndentLevel -= 1

    return $UserPrivilegesResult
}
# ----------------------------------------------------------------
# END PRIVILEGES    
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN CREDENTIALS     
# ----------------------------------------------------------------
function Invoke-WinlogonCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    General notes
    #>

    [CmdletBinding()] param()

    $WinlogonResult = New-Object -TypeName PSObject 
    
    $Item = Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"

    if ($Item.DefaultDomainName -Or $Item.DefaultUserName -Or $Item.DefaultPassword) {

        $WinlogonResult | Add-Member -MemberType "NoteProperty" -Name "Domain" -Value $Item.DefaultDomainName
        $WinlogonResult | Add-Member -MemberType "NoteProperty" -Name "Username" -Value $Item.DefaultUserName
        $WinlogonResult | Add-Member -MemberType "NoteProperty" -Name "Password" -Value $Item.DefaultPassword

        if ($Item.DefaultDomainName) {
            Write-Message -Level Info "Domain: $($Item.DefaultDomainName)"
        }
        if ($Item.DefaultUserName) {
            Write-Message -Level Info "User: $($Item.DefaultUserName)"
        }
        if ($Item.DefaultPassword) {
            Write-Message -Level Success "Password: $($Item.DefaultPassword)"
        }
    } else {
        $WinlogonResult = $Null 
        Write-Message -Level Info "Nothing found."
    }

    return $WinlogonResult
}

function Invoke-CredentialFilesCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    Get file content with https://github.com/AlessandroZ/LaZagne ???
    #>
    
    [CmdletBinding()] param()

    function Get-CredentialFiles {
        [CmdletBinding()] param(
            [string]
            $Path 
        )
        $Result = New-Object System.Collections.ArrayList
        $Items = Get-ChildItem -Hidden -Path $Path -ErrorAction SilentlyContinue -ErrorVariable Errors 
        if (-not $Errors) {
            ForEach ($Item in $Items) {
                $FullPath = Join-Path -Path $Path -ChildPath $Item.Name 
                $FileObject = New-Object -TypeName PSObject 
                $FileObject | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Item.Name
                $FileObject | Add-Member -MemberType "NoteProperty" -Name "FullPath" -Value $FullPath
                [void]$Result.Add($FileObject)
            }
        }
        return $Result
    }

    $ArrayOfCredentialFiles = New-Object System.Collections.ArrayList

    $PathLocalAppData = Join-Path -Path $env:LOCALAPPDATA -ChildPath "Microsoft\Credentials"
    $PathAppData = Join-Path -Path $env:APPDATA -ChildPath "Microsoft\Credentials"

    [void]$ArrayOfCredentialFiles.AddRange([object[]]$(Get-CredentialFiles -Path $PathLocalAppData))
    [void]$ArrayOfCredentialFiles.AddRange([object[]]$(Get-CredentialFiles -Path $PathAppData))

    Write-Message -Level Info "Found $(([object[]]$ArrayOfCredentialFiles).Length) credential files"
    if (([object[]]$ArrayOfCredentialFiles).Length -gt 0) {
        ForEach ($CredentialFile in $ArrayOfCredentialFiles) {
            $GlobalIndentLevel += 1
            Write-Message -Level Info "Path: $($CredentialFile.FullPath)"
            $GlobalIndentLevel -= 1
        }
    }

    return $ArrayOfCredentialFiles
}
# ----------------------------------------------------------------
# END CREDENTIALS     
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN SENSITIVE FILES 
# ----------------------------------------------------------------
function Invoke-SamBackupFilesCheck {
    
    [CmdletBinding()] param()

    $SamBackupFiles = New-Object System.Collections.ArrayList

    $ArrayOfPaths = New-Object System.Collections.ArrayList 
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "repair\SAM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\RegBack\SAM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\SAM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "repair\system"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\SYSTEM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\RegBack\system"))

    ForEach ($Path in [string[]]$ArrayOfPaths) {
        $GlobalIndentLevel +=1
        Clear-Variable -Name Error 
        if (Test-Path -Path $Path) { 
            $CanRead = $False 
            $SamBackupFile = New-Object -TypeName PSObject   
            Get-Content -Path $Path -ErrorAction SilentlyContinue -ErrorVariable Error | Out-Null 
            if (-not $Error) {
                $CanRead = $True 
                Write-Message -Level Success "Found readable file: $($Path)"
            } else {
                Write-Message -Level Info "Found file: $($Path)"
            }  
            $SamBackupFile | Add-Member -MemberType "NoteProperty" -Name "Path" -Value $Path 
            $SamBackupFile | Add-Member -MemberType "NoteProperty" -Name "IsReadable" -Value $CanRead
            [void]$SamBackupFiles.Add($SamBackupFile) 
        }
        $GlobalIndentLevel -=1
    }

    return $SamBackupFiles
}
# ----------------------------------------------------------------
# END SENSITIVE FILES 
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN INSTALLED PROGRAMS   
# ----------------------------------------------------------------
function Invoke-InstalledProgramsCheck {
    [CmdletBinding()] param()

    $InstalledProgramsResult = New-Object System.Collections.ArrayList 

    $Items = Get-InstalledPrograms -Filtered

    ForEach ($Item in $Items) {
        $CurrentFileName = $Item.Name 
        $CurrentFileFullname = $Item.FullName
        $AppItem = New-Object -TypeName PSObject 
        $AppItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $CurrentFileName
        $AppItem | Add-Member -MemberType "NoteProperty" -Name "FullPath" -Value $CurrentFileFullname
        [void]$InstalledProgramsResult.Add($AppItem)
    }

    $InstalledProgramsResultLen = ([object[]]$InstalledProgramsResult).Length
    if ($InstalledProgramsResultLen -gt 0) {
        Write-Message -Level Info "Found $(([object[]]$InstalledProgramsResult).Length) third-party applications."
        $OutString = ""
        For ($i = 0; $i -lt $InstalledProgramsResultLen; $i++) {
            $OutString += "'$($InstalledProgramsResult[$i].Name)'"
            if (-not ($i -eq ($InstalledProgramsResultLen - 1))) {
                $OutString += ", "
            }
        }
        $GlobalIndentLevel += 1
        Write-Message -Level Info "Application list: $($OutString)"
        $GlobalIndentLevel -= 1       
    } else {
        Write-Message -Level Warning "Didn't find any third-party application."
    }
    
    return $InstalledProgramsResult
}

function Invoke-ModifiableProgramsCheck {
    [CmdletBinding()] param()

    $ModifiableProgramsResult = New-Object -TypeName System.Collections.ArrayList

    #$ModifiablePaths = New-Object -TypeName System.Collections.ArrayList
    $Items = Get-InstalledPrograms -Filtered

    Write-Message -Level Info "Searching for modifiable files/folders in $(([object[]]$Items).Length) applications..."

    $GlobalIndentLevel += 1
    ForEach ($Item in $Items) {
        #$SearchPath = New-Object -TypeName System.Collections.ArrayList
        #[void]$SearchPath.Add([string]$(Join-Path -Path $Item.FullName -ChildPath "\*")) # Do this to avoid the use of -Depth which is PSH3+
        #[void]$SearchPath.Add([string]$(Join-Path -Path $Item.FullName -ChildPath "\*\*")) # Do this to avoid the use of -Depth which is PSH3+
        #$ChildItems = Get-ChildItem -Path $SearchPath -ErrorAction SilentlyContinue -ErrorVariable GetChildItemError # Do this to avoid the use of -Depth which is PSH3+
        $ChildItems = $Item | Get-ChildItem -Recurse -Depth 2 -ErrorAction SilentlyContinue -ErrorVariable GetChildItemError 
        if (-not $GetChildItemError) {
            $ChildItems | ForEach-Object {
                if ($_ -is [System.IO.DirectoryInfo]) {
                    $IsDirectory = $True
                    $GetModifiablePathsResult = $_ | Get-ModifiablePath -LiteralPaths
                    if ($GetModifiablePathsResult) {
                        $ModifiableProgram = New-Object -TypeName PSObject 
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "ModifiablePath" -Value $GetModifiablePathsResult[0].ModifiablePath 
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IsDirectory" -Value $IsDirectory
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IdentityReference" -Value $GetModifiablePathsResult[0].IdentityReference 
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "Permissions" -Value $GetModifiablePathsResult[0].Permissions 
                        [void]$ModifiableProgramsResult.Add([object]$ModifiableProgram)
                        Write-Message -Level Success "Found modifiable directory: $($_.FullName)"
                    }
                } else {
                    $IsDirectory = $False
                    # Check only .exe and .dll ???
                    # TODO: maybe consider other extensions 
                    if ($_.FullName -Like "*.exe" -or $_.FullName -Like "*.dll") {
                        $GetModifiablePathsResult = $_ | Get-ModifiablePath -LiteralPaths
                        ForEach($Result in $GetModifiablePathsResult) {
                            $ModifiableProgram = New-Object -TypeName PSObject 
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "ModifiablePath" -Value $Result.ModifiablePath 
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IsDirectory" -Value $IsDirectory
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IdentityReference" -Value $Result.IdentityReference 
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "Permissions" -Value $Result.Permissions 
                            [void]$ModifiableProgramsResult.Add([object]$ModifiableProgram)
                            Write-Message -Level Success "Found modifiable file: $($_.FullName)"
                        }
                    }
                }
            }
        }
    }
    $GlobalIndentLevel -= 1

    if (([object[]]$ModifiableProgramsResult).Length -eq 0) {
        Write-Message -Level Warning "Didn't find any modifiable path."
    }

    return $ModifiableProgramsResult
}
# ----------------------------------------------------------------
# END INSTALLED PROGRAMS   
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN SERVICES   
# ----------------------------------------------------------------
function Invoke-InstalledServicesCheck {
    [CmdletBinding()] param()

    function Write-ArrayOfServices {
        [CmdletBinding()] param(
            [object[]]
            $Services
        )

        if (([object[]]$Services).Length -gt 0) {
            $User = $Services[0].User 
            if ($User -eq "LocalSystem") {
                Write-Message -Level Info "Found $(([object[]]$Services).Length) service(s) running as LocalSystem."
            } else {
                Write-Message -Level Info "Found $(([object[]]$Services).Length) other service(s)."
            }
            $GlobalIndentLevel += 1
            ForEach ($Service in $Services) {
                Write-Message -Level Info "Service: '$($Service.Name)' ($($Service.DisplayName)) - User: $($Service.User) - StartMode: $($Service.StartMode)"
            }
            $GlobalIndentLevel -= 1
        }
    }

    $InstalledServicesResult = New-Object -TypeName System.Collections.ArrayList

    $FilteredServices = Get-ServiceList -Filtered

    Write-Message -Level Info "Found $(([object[]]$FilteredServices).Length) third-party services."

    $ServicesRunningAsSystem = New-Object -TypeName System.Collections.ArrayList
    $ServicesRunningAsOther = New-Object -TypeName System.Collections.ArrayList
    ForEach ($Service in $FilteredServices) {
        $Properties = Get-ItemProperty -Path $Service.RegistryPath -ErrorAction SilentlyContinue -ErrorVariable GetItemPropertyError 
        if (-not $GetItemPropertyError) {
            $ServiceItem = New-Object -TypeName PSObject 
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Properties.PSChildName
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "DisplayName" -Value $Properties.DisplayName
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "User" -Value $Properties.ObjectName 
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "ImagePath" -Value $Properties.ImagePath 
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "StartMode" -Value $(Convert-ServiceStartModeToString -StartMode $Properties.Start)
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "Type" -Value $(Convert-ServiceTypeToString -ServiceType $Properties.Type)
            [void]$InstalledServicesResult.Add($ServiceItem)

            if ($Properties.ObjectName -eq "LocalSystem") {
                [void]$ServicesRunningAsSystem.Add($ServiceItem)
            } else {
                [void]$ServicesRunningAsOther.Add($ServiceItem)
            }
        }
    }

    Write-ArrayOfServices -Services $ServicesRunningAsSystem
    Write-ArrayOfServices -Services $ServicesRunningAsOther

    return $InstalledServicesResult
}
# ----------------------------------------------------------------
# END SERVICES   
# ----------------------------------------------------------------
#endregion Checks


# ----------------------------------------------------------------
# Main  
# ----------------------------------------------------------------
#region Main
function Invoke-PrivescCheck {

    [CmdletBinding()] param()

    $Results = $Null ; $Results | Out-Null # Remove variable not used warning 

    "----------------------------------------------------------------"
    "|                          PRIVILEGES                          |"
    "----------------------------------------------------------------"

    "Checking user privileges"
    $Results = Invoke-UserPrivilegesCheck
    #$Results | Format-List 

    Write-Host ""


    "----------------------------------------------------------------"
    "|                           SERVICES                           |"
    "----------------------------------------------------------------"

    "Listing third-party services"
    $Results = Invoke-InstalledServicesCheck
    #$Results | Format-List

    Write-Host ""

    #"Checking services permissions (registry)"
    #$Results = Invoke-ServicesPermissionsRegistryCheck
    #$Results | Format-List

    #Write-Host ""

    #"Checking services permissions"
    #$Results = Invoke-ServicesPermissionsCheck
    #$Results | Format-List

    #Write-Host ""
    
    #"Checking for unquoted service paths"
    #$Results = Invoke-ServicesUnquotedPathCheck
    #$Results | Format-List

    #Write-Host ""

    #"Checking service executable and argument permissions"
    #$Results = Invoke-ServicesUnquotedPathCheck
    #$Results | Format-List

    #Write-Host ""


    "----------------------------------------------------------------"
    "|                        SENSITIVE FILES                       |"
    "----------------------------------------------------------------"

    "Checking SAM backup files"
    $Results = Invoke-SamBackupFilesCheck
    #$Results | Format-List 

    Write-Host ""


    "----------------------------------------------------------------"
    "|                       INSTALLED PROGRAMS                      |"
    "----------------------------------------------------------------"
    "Listing installed programs except the ones from Microsoft"
    $Results = Invoke-InstalledProgramsCheck
    #$Results | Format-List 

    Write-Host ""
    
    "Checking modifiable programs"
    $Results = Invoke-ModifiableProgramsCheck
    #$Results | Format-List

    Write-Host ""


    "----------------------------------------------------------------"
    "|                          CREDENTIALS                         |"
    "----------------------------------------------------------------"

    "Checking WinLogon registry key"
    $Results = Invoke-WinlogonCheck
    #$Results | Format-List 

    Write-Host ""

    "Checking Credential files"
    $Results = Invoke-CredentialFilesCheck
    #$Results | Format-List

    Write-Host ""


    "----------------------------------------------------------------"
    "|                              MISC                            |"
    "----------------------------------------------------------------"

    "Checking system version"
    $Results = Invoke-SystemInfoCheck
    #$Results | Format-List 

    Write-Host ""

    "Checking machine role (Workstation, server, DC)"
    $Results = Invoke-MachineRoleCheck 
    #$Results | Format-List 

    Write-Host ""

    "Checking last Windows Update installation date"
    $Results = Invoke-WindowsUpdateCheck 
    #$Results | Format-List 

    Write-Host ""

    "Checking local admin group"
    $Results = Invoke-LocalAdminGroupCheck
    #$Results | Format-List 
    
    Write-Host ""

    "Checking system startup history"
    $Results = Invoke-SystemStartupHistoryCheck
    #$Results | Format-List 

    Write-Host ""

    "Checking file system drives"
    $Results = Invoke-SystemDrivesCheck
    #$Results | Format-List 

    Write-Host ""

}
#endregion Main
