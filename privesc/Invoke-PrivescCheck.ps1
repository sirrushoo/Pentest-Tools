<#

https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/
https://book.hacktricks.xyz/windows/windows-local-privilege-escalation
#>

#Requires -Version 3

# ----------------------------------------------------------------
# Win32 stuff  
# ----------------------------------------------------------------
#region Win32
<#
https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1
https://rohnspowershellblog.wordpress.com/2013/03/19/viewing-service-acls/
#>
$MethodDefinition = @'
[System.FlagsAttribute]
public enum ServiceAccessFlags : uint
{
    QueryConfig = 1,
    ChangeConfig = 2,
    QueryStatus = 4,
    EnumerateDependents = 8,
    Start = 16,
    Stop = 32,
    PauseContinue = 64,
    Interrogate = 128,
    UserDefinedControl = 256,
    Delete = 65536,
    ReadControl = 131072,
    WriteDac = 262144,
    WriteOwner = 524288,
    Synchronize = 1048576,
    AccessSystemSecurity = 16777216,
    GenericAll = 268435456,
    GenericExecute = 536870912,
    GenericWrite = 1073741824,
    GenericRead = 2147483648
}

[DllImport("advapi32.dll", SetLastError=true)]
public static extern bool QueryServiceObjectSecurity(IntPtr serviceHandle, System.Security.AccessControl.SecurityInfos secInfo, byte[] lpSecDesrBuf, uint bufSize, out uint bufSizeNeeded);

[DllImport("advapi32.dll", SetLastError=true)]
[return: MarshalAs(UnmanagedType.Bool)]
public static extern bool CloseServiceHandle(IntPtr hSCObject);
'@

try {
    # Is the Type already defined?
    [PrivescCheck.Win32] | Out-Null 
} catch {
    # If not, create it by compiling the C# code in memory 
    $CompilerParameters = New-Object -TypeName System.CodeDom.Compiler.CompilerParameters
    $CompilerParameters.GenerateInMemory = 1
    $CompilerParameters.ReferencedAssemblies.AddRange(@("System.dll", "System.Core.dll", "mscorlib.dll", "System.Windows.Forms.dll", $([PSObject].Assembly.Location)))
    Add-Type -MemberDefinition $MethodDefinition -Name 'Win32' -Namespace 'PrivescCheck' -Language CSharp -CompilerParameters $CompilerParameters
}
#endregion Win32


# ----------------------------------------------------------------
# Helpers 
# ----------------------------------------------------------------
#region Helpers 
$global:IndentLevel = 0
$global:DirectOutput = $False 

$global:IgnoredPrograms = @("Common Files", "Internet Explorer", "ModifiableWindowsApps", "VMware", "Windows Defender", "Windows Defender Advanced Threat Protection", "Windows Mail", "Windows Media Player", "Windows Multimedia Platform", "Windows NT", "Windows Photo Viewer", "Windows Portable Devices", "Windows Security", "WindowsPowerShell", "Microsoft.NET", "Windows Portable Devices", "dotnet", "MSBuild", "Intel", "Reference Assemblies")

$global:IgnoredServices = @("1394ohci", "3ware", "AarSvc", "ACPI", "AcpiDev", "acpiex", "acpipagr", "AcpiPmi", "acpitime", "Acx01000", "ADOVMPPackage", "ADP80XX", "adsi", "AFD", "afunix", "ahcache", "AJRouter", "ALG", "amdgpio2", "amdi2c", "AmdK8", "AmdPPM", "amdsata", "amdsbs", "amdxata", "AppID", "AppIDSvc", "Appinfo", "applockerfltr", "AppMgmt", "AppReadiness", "AppVClient", "AppvStrm", "AppvVemgr", "AppvVfs", "AppXSvc", "arcsas", "AssignedAccessManagerSvc", "AsyncMac", "atapi", "AudioEndpointBuilder", "Audiosrv", "autotimesvc", "AxInstSV", "b06bdrv", "bam", "BasicDisplay", "BasicRender", "BattC", "BcastDVRUserService", "bcmfn2", "BDESVC", "Beep", "BFE", "bindflt", "BITS", "BluetoothUserService", "bowser", "BrokerInfrastructure", "Browser", "BTAGService", "BthA2dp", "BthAvctpSvc", "BthEnum", "BthHFEnum", "BthLEEnum", "BthMini", "BTHMODEM", "BthPan", "BTHPORT", "bthserv", "BTHUSB", "bttflt", "buttonconverter", "CAD", "camsvc", "CaptureService", "cbdhsvc", "cdfs", "CDPSvc", "CDPUserSvc", "cdrom", "CertPropSvc", "cht4iscsi", "cht4vbd", "CimFS", "circlass", "CldFlt", "CLFS", "ClipSVC", "CmBatt", "CNG", "cnghwassist", "CompositeBus", "COMSysApp", "condrv", "ConsentUxUserSvc", "CoreMessagingRegistrar", "CoreUI", "CredentialEnrollmentManagerUserSvc", "crypt32", "CryptSvc", "CSC", "CscService", "dam", "DCLocator", "DcomLaunch", "defragsvc", "DeviceAssociationBrokerSvc", "DeviceAssociationService", "DeviceInstall", "DevicePickerUserSvc", "DevicesFlowUserSvc", "DevQueryBroker", "Dfsc", "Dhcp", "diagnosticshub.standardcollector.service", "diagsvc", "DiagTrack", "disk", "DispBrokerDesktopSvc", "DisplayEnhancementService", "DmEnrollmentSvc", "dmvsc", "dmwappushservice", "Dnscache", "DoSvc", "dot3svc", "DPS", "drmkaud", "DsmSvc", "DsSvc", "DusmSvc", "DXGKrnl", "e1i65x64", "Eaphost", "ebdrv", "EFS", "EhStorClass", "EhStorTcgDrv", "embeddedmode", "EntAppSvc", "ErrDev", "ESENT", "EventLog", "EventSystem", "exfat", "fastfat", "Fax", "fdc", "fdPHost", "FDResPub", "fhsvc", "FileCrypt", "FileInfo", "Filetrace", "flpydisk", "FltMgr", "FontCache", "FrameServer", "FsDepends", "Fs_Rec", "fvevol", "gencounter", "genericusbfn", "GPIOClx0101", "gpsvc", "GpuEnergyDrv", "GraphicsPerfSvc", "HdAudAddService", "HDAudBus", "HidBatt", "HidBth", "hidi2c", "hidinterrupt", "HidIr", "hidserv", "hidspi", "HidUsb", "HomeGroupListener", "HomeGroupProvider", "HpSAMD", "HTTP", "hvcrash", "HvHost", "hvservice", "HwNClx0101", "hwpolicy", "hyperkbd", "HyperVideo", "i8042prt", "iagpio", "iai2c", "iaLPSS2i_GPIO2", "iaLPSS2i_GPIO2_BXT_P", "iaLPSS2i_GPIO2_CNL", "iaLPSS2i_GPIO2_GLK", "iaLPSS2i_I2C", "iaLPSS2i_I2C_BXT_P", "iaLPSS2i_I2C_CNL", "iaLPSS2i_I2C_GLK", "iaLPSSi_GPIO", "iaLPSSi_I2C", "iaStorAV", "iaStorAVC", "iaStorV", "ibbus", "icssvc", "IKEEXT", "IndirectKmd", "inetaccs", "InstallService", "intelide", "intelpep", "intelpmax", "intelppm", "iorate", "IpFilterDriver", "iphlpsvc", "IPMIDRV", "IPNAT", "IPT", "IpxlatCfgSvc", "isapnp", "iScsiPrt", "ItSas35i", "kbdclass", "kbdhid", "kdnic", "KeyIso", "KSecDD", "KSecPkg", "ksthunk", "KtmRm", "LanmanServer", "LanmanWorkstation", "ldap", "lfsvc", "LicenseManager", "lltdio", "lltdsvc", "lmhosts", "Lsa", "LSI_SAS", "LSI_SAS2i", "LSI_SAS3i", "LSI_SSS", "LSM", "luafv", "LxpSvc", "MapsBroker", "mausbhost", "mausbip", "MbbCx", "megasas", "megasas2i", "megasas35i", "megasr", "MessagingService", "Microsoft_Bluetooth_AvrcpTransport", "MixedRealityOpenXRSvc", "mlx4_bus", "MMCSS", "Modem", "monitor", "mouclass", "mouhid", "mountmgr", "mpsdrv", "mpssvc", "MRxDAV", "mrxsmb", "mrxsmb20", "MsBridge", "Msfs", "msgpiowin32", "mshidkmdf", "mshidumdf", "msisadrv", "MSiSCSI", "msiserver", "MSKSSRV", "MsLldp", "MSPCLOCK", "MSPQM", "MsQuic", "MsRPC", "MSSCNTRS", "MsSecFlt", "mssmbios", "MSTEE", "MTConfig", "Mup", "mvumis", "napagent", "NativeWifiP", "NaturalAuthentication", "NcaSvc", "NcbService", "NcdAutoSetup", "ndfltr", "NDIS", "NdisCap", "NdisImPlatform", "NdisTapi", "Ndisuio", "NdisVirtualBus", "NdisWan", "ndiswanlegacy", "NDKPing", "ndproxy", "Ndu", "NetAdapterCx", "NetBIOS", "NetbiosSmb", "NetBT", "Netlogon", "Netman", "netprofm", "NetSetupSvc", "NetTcpPortSharing", "netvsc", "NgcCtnrSvc", "NgcSvc", "NlaSvc", "Npfs", "npsvctrig", "nsi", "nsiproxy", "NTDS", "Ntfs", "Null", "nvdimm", "nvraid", "nvstor", "OneSyncSvc", "p2pimsvc", "p2psvc", "Parport", "partmgr", "PcaSvc", "pci", "pciide", "pcmcia", "pcw", "pdc", "PEAUTH", "PeerDistSvc", "perceptionsimulation", "percsas2i", "percsas3i", "PerfDisk", "PerfHost", "PerfNet", "PerfOS", "PerfProc", "PhoneSvc", "PimIndexMaintenanceSvc", "PktMon", "pla", "PlugPlay", "pmem", "PNPMEM", "PNRPAutoReg", "PNRPsvc", "PolicyAgent", "portcfg", "PortProxy", "Power", "PptpMiniport", "PrintNotify", "PrintWorkflowUserSvc", "Processor", "ProfSvc", "Psched", "PushToInstall", "pvscsi", "QWAVE", "QWAVEdrv", "Ramdisk", "RasAcd", "RasAgileVpn", "RasAuto", "Rasl2tp", "RasMan", "RasPppoe", "RasSstp", "rdbss", "RDMANDK", "rdpbus", "RDPDR", "RDPNP", "RDPUDD", "RdpVideoMiniport", "rdyboost", "ReFS", "ReFSv1", "RemoteAccess", "RemoteRegistry", "RetailDemo", "RFCOMM", "rhproxy", "RmSvc", "RpcEptMapper", "RpcLocator", "RpcSs", "rspndr", "s3cap", "SamSs", "sbp2port", "SCardSvr", "ScDeviceEnum", "scfilter", "Schedule", "scmbus", "SCPolicySvc", "sdbus", "SDFRd", "SDRSVC", "sdstor", "seclogon", "SecurityHealthService", "SEMgrSvc", "SENS", "Sense", "SensorDataService", "SensorService", "SensrSvc", "SerCx", "SerCx2", "Serenum", "Serial", "sermouse", "SessionEnv", "sfloppy", "SgrmAgent", "SgrmBroker", "SharedAccess", "SharedRealitySvc", "ShellHWDetection", "shpamsvc", "SiSRaid2", "SiSRaid4", "SmartSAMD", "smbdirect", "smphost", "SmsRouter", "SMSvcHost 4.0.0.0", "SNMPTRAP", "spaceparser", "spaceport", "SpatialGraphFilter", "SpbCx", "spectrum", "Spooler", "sppsvc", "srv2", "srvnet", "SSDPSRV", "ssh-agent", "SstpSvc", "StateRepository", "stexstor", "stisvc", "storahci", "storflt", "stornvme", "storqosflt", "StorSvc", "storufs", "storvsc", "svsvc", "swenum", "swprv", "Synth3dVsc", "SysMain", "SystemEventsBroker", "TabletInputService", "TapiSrv", "Tcpip", "Tcpip6", "TCPIP6TUNNEL", "tcpipreg", "TCPIPTUNNEL", "tdx", "Telemetry", "terminpt", "TermService", "Themes", "TieringEngineService", "TimeBrokerSvc", "TokenBroker", "TPM", "TrkWks", "TroubleshootingSvc", "TrustedInstaller", "TSDDD", "TsUsbFlt", "TsUsbGD", "tsusbhub", "tunnel", "tzautoupdate", "UASPStor", "UcmCx0101", "UcmTcpciCx0101", "UcmUcsiAcpiClient", "UcmUcsiCx0101", "Ucx01000", "UdeCx", "udfs", "UdkUserSvc", "UEFI", "UevAgentDriver", "UevAgentService", "Ufx01000", "UfxChipidea", "ufxsynopsys", "UGatherer", "UGTHRSVC", "umbus", "UmPass", "UmRdpService", "UnistoreSvc", "upnphost", "UrsChipidea", "UrsCx01000", "UrsSynopsys", "usbaudio", "usbaudio2", "usbccgp", "usbcir", "usbehci", "usbhub", "USBHUB3", "usbohci", "usbprint", "usbser", "USBSTOR", "usbuhci", "USBXHCI", "UserDataSvc", "UserManager", "UsoSvc", "VacSvc", "VaultSvc", "vdrvroot", "vds", "VerifierExt", "VGAuthService", "vhdmp", "vhf", "Vid", "VirtualRender", "vm3dmp", "vm3dmp-debug", "vm3dmp-stats", "vm3dmp_loader", "vmbus", "VMBusHID", "vmci", "vmgid", "vmhgfs", "vmicguestinterface", "vmicheartbeat", "vmickvpexchange", "vmicrdv", "vmicshutdown", "vmictimesync", "vmicvmsession", "vmicvss", "VMMemCtl", "vmmouse", "vmrawdsk", "vmusbmouse", "vmvss", "vmwefifw", "vmxnet3ndis6", "volmgr", "volmgrx", "volsnap", "volume", "vpci", "vsmraid", "vsock", "VSS", "VSTXRAID", "vwifibus", "vwififlt", "W32Time", "WaaSMedicSvc", "WacomPen", "WalletService", "wanarp", "wanarpv6", "WarpJITSvc", "wbengine", "WbioSrvc", "wcifs", "Wcmsvc", "wcncsvc", "wcnfs", "WdBoot", "Wdf01000", "WdFilter", "WdiServiceHost", "WdiSystemHost", "wdiwifi", "WdmCompanionFilter", "WdNisDrv", "WdNisSvc", "WebClient", "Wecsvc", "WEPHOSTSVC", "wercplsupport", "WerSvc", "WFDSConMgrSvc", "WFPLWFS", "WiaRpc", "WIMMount", "WinDefend", "Windows Workflow Foundation 4.0.0.0", "WindowsTrustedRT", "WindowsTrustedRTProxy", "WinHttpAutoProxySvc", "WinMad", "Winmgmt", "WinNat", "WinRM", "Winsock", "WinSock2", "WINUSB", "WinVerbs", "wisvc", "WlanSvc", "wlidsvc", "wlpasvc", "WManSvc", "WmiAcpi", "WmiApRpl", "wmiApSrv", "WMPNetworkSvc", "Wof", "workerdd", "workfolderssvc", "WpcMonSvc", "WPDBusEnum", "WpdUpFltr", "WpnService", "WpnUserService", "ws2ifsl", "wscsvc", "WSearch", "WSearchIdxPi", "wuauserv", "WudfPf", "WUDFRd", "WwanSvc", "XblAuthManager", "XblGameSave", "xboxgip", "XboxGipSvc", "XboxNetApiSvc", "xinputhid", "xmlprov")

function Write-Message {
    [CmdletBinding()] param(
        [String]
        $Message,
        [ValidateSet("Success", "Info", "Warning", "Error")]
        [String]
        $Level
    )

    $Padding = ""
    For ($i = 0; $i -lt $global:IndentLevel; $i++) {
        $Padding += "    "
    }

    $Sign = ""
    $Color = ""
    if ($Level -eq "Success") {
        $Sign = "[+]"
        $Color = "Green"
    } elseif ($Level -eq "Info") {
        $Sign = "[*]"
        $Color = "Blue"
    } elseif ($Level -eq "Warning") {
        $Sign = "[!]"
        $Color = "Yellow"
    } elseif ($Level -eq "Error") {
        $Sign = "[-]"
        $Color = "Red"
    } 

    if ($global:DirectOutput) {
        "$($Padding)$($Sign) $($Message)"
    } else {
        Write-Host -NoNewLine $Padding
        Write-Host -NoNewline -ForegroundColor $Color "[+] "
        Write-Host $Message
    }
}

function Convert-DateToString {
    [CmdletBinding()] param(
        [System.DateTime]
        $Date
    )

    return $Date.ToString('yyyy-MM-dd - HH:mm:ss')
}

function Convert-ServiceTypeToString {
    [CmdletBinding()] param(
        [int]
        $ServiceType
    )

    $Result = ""

    if ($ServiceType -eq 1) {
        $Result = "KernelDriver"
    } elseif ($ServiceType -eq 2) {
        $Result = "FileSystemDriver"
    } elseif ($ServiceType -eq 4) {
        $Result = "Adapter"
    } elseif ($ServiceType -eq 8) {
        $Result = "RecognizerDriver"
    } elseif ($ServiceType -eq 16) {
        $Result = "Win32OwnProcess"
    } elseif ($ServiceType -eq 32) {
        $Result = "Win32ShareProcess"
    } elseif ($ServiceType -eq 256) {
        $Result = "InteractiveProcess"
    } else {
        $Result = "Unknown"
    }

    return $Result
}

function Convert-ServiceStartModeToString {
    [CmdletBinding()] param(
        [int]
        $StartMode
    )

    $Result = ""

    if ($StartMode -eq 0) {
        $Result = "Boot"
    } elseif ($StartMode -eq 1) {
        $Result = "System"
    } elseif ($StartMode -eq 2) {
        $Result = "Automatic"
    } elseif ($StartMode -eq 3) {
        $Result = "Manual"
    } elseif ($StartMode -eq 4) {
        $Result = "Disabled"
    } else {
        $Result = "Unknown"
    }

    return $Result
}

function Test-IsKnownService {
    [CmdletBinding()] param(
        [string]
        $ServiceName
    )

    $KnownServices = @("AarSvc_*", "BcastDVRUserService_*", "BluetoothUserService_*", "CaptureService_*", "cbdhsvc_*", "CDPUserSvc_*", "clr_optimization_*", "ConsentUxUserSvc_*", "CredentialEnrollmentManagerUserSvc_*", "DeviceAssociationBrokerSvc_*", "DevicePickerUserSvc_*", "DevicesFlowUserSvc_*", "FontCache*", "IpOverUsbSvc", "MessagingService_*", "MSDTC*", ".NET*", "OneSyncSvc_*", "PimIndexMaintenanceSvc_*", "PrintWorkflowUserSvc_*", "UdkUserSvc_*", "UnistoreSvc_*", "UserDataSvc_*", "WpnUserService_*")

    if ($global:IgnoredServices -contains $ServiceName) {
        return $True 
    } else {
        ForEach ($KnownService in $KnownServices) {
            if ($ServiceName -like $KnownService) {
                return $True 
            }
        }
    }
    return $False 
}

function Get-InstalledPrograms {
    [CmdletBinding()] param(
        [switch]
        $Filtered = $False
    )

    $InstalledProgramsResult = New-Object System.Collections.ArrayList

    $InstalledPrograms = New-Object System.Collections.ArrayList

    $PathProgram32 = Join-Path -Path $env:SystemDrive -ChildPath "Program Files (x86)"
    $PathProgram64 = Join-Path -Path $env:SystemDrive -ChildPath "Program Files" 

    $Items = Get-ChildItem -Path $PathProgram32,$PathProgram64 -ErrorAction SilentlyContinue
    if ($Items) {
        [void]$InstalledPrograms.AddRange($Items)
    }
    
    $RegInstalledPrograms = Get-ChildItem -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"
    ForEach ($InstalledProgram in $RegInstalledPrograms) {
        $InstallLocation = [System.Environment]::ExpandEnvironmentVariables($InstalledProgram.GetValue("InstallLocation"))
        if ($InstallLocation) {
            if (Test-Path -Path $InstallLocation -ErrorAction SilentlyContinue) {
                if ($InstallLocation[$InstallLocation.Length - 1] -eq "\") {
                    $InstallLocation = $InstallLocation.SubString(0, $InstallLocation.Length - 1)
                }
                $FileObject = Get-Item -Path $InstallLocation -ErrorAction SilentlyContinue -ErrorVariable GetItemError 
                if ($GetItemError) {
                    continue 
                }
                if ($FileObject -is [System.IO.DirectoryInfo]) {
                    continue
                }
                [void]$InstalledPrograms.Add([object]$FileObject)
            }
        }
    }

    $PathListResult = New-Object System.Collections.ArrayList
    ForEach ($InstalledProgram in $InstalledPrograms) {
        if (-not ($PathListResult -contains $InstalledProgram.FullName)) {
            [void]$InstalledProgramsResult.Add($InstalledProgram)
            [void]$PathListResult.Add($InstalledProgram.FullName)
        }
    }

    if ($Filtered) {
        $InstalledProgramsResultFiltered = New-Object -TypeName System.Collections.ArrayList
        ForEach ($InstalledProgram in $InstalledProgramsResult) {
            if (-Not ($global:IgnoredPrograms -contains $InstalledProgram.Name)) {
                if (-Not (($InstalledProgram.Name -Like "Windows*") -Or ($InstalledProgram.Name -Like "Microsoft*"))) {
                    [void]$InstalledProgramsResultFiltered.Add($InstalledProgram)
                }
            }
        }
        return $InstalledProgramsResultFiltered
    }
    
    return $InstalledProgramsResult
}

function Get-ServiceList {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .PARAMETER Filtered
    Parameter description
    
    .PARAMETER FilterLevel
    FilterLevel = 0 - No filtering 
    FilterLevel = 1 - Exclude 'Services with empty ImagePath'
    FilterLevel = 2 - Exclude 'Services with empty ImagePath' + 'Drivers' 
    FilterLevel = 3 - Exclude 'Services with empty ImagePath' + 'Drivers' + 'Known services' 
    
    .EXAMPLE
    An example
    
    .NOTES
    Service types: KernelDriver(1), FileSystemDriver(2), Adapter(4), RecognizerDriver(8), Win32OwnProcess(16), Win32ShareProcess(32), InteractiveProcess(256)
    #>
    
    [CmdletBinding()] param(
        [ValidateSet(0,1,2,3)]
        [int]
        $FilterLevel = 0
    )

    $ServiceListResult = New-Object -TypeName System.Collections.ArrayList

    $ServicesRegPath = "Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services" 
    $RegAllServices = Get-ChildItem -Path $ServicesRegPath

    ForEach ($RegService in $RegAllServices) {

        $Properties = Get-ItemProperty -Path $RegService.PSPath -ErrorAction SilentlyContinue -ErrorVariable GetItemPropertyError
        if ($GetItemPropertyError) {
            # If an error occurred, skip the current item 
            continue 
        } 

        #$TriggerInfoPath = Join-Path -Path $ServicesRegPath -ChildPath $Properties.PSChildName
        #$TriggerInfoPath = Join-Path -Path $TriggerInfoPath -ChildPath "TriggerInfo" 

        #$TriggerInfo = Get-ChildItem -Path $TriggerInfoPath -ErrorAction SilentlyContinue -ErrorVariable GetChildItemError
        #if (-not $GetChildItemError) {
        #    if ($TriggerInfo.Length -gt 0) {
        #        $HasTriggerInfo = $True 
        #    } else {
        #        $HasTriggerInfo = $False 
        #    }
        #} else {
        #    $HasTriggerInfo = $False 
        #}

        $ServiceItem = New-Object -TypeName PSObject 
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Properties.PSChildName
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "DisplayName" -Value $Properties.DisplayName
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "User" -Value $Properties.ObjectName 
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "ImagePath" -Value $Properties.ImagePath 
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "StartMode" -Value $(Convert-ServiceStartModeToString -StartMode $Properties.Start)
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "Type" -Value $(Convert-ServiceTypeToString -ServiceType $Properties.Type)
        #$ServiceItem | Add-Member -MemberType "NoteProperty" -Name "HasTriggerInfo" -Value $HasTriggerInfo
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "RegistryKey" -Value $RegService.Name
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "RegistryPath" -Value $RegService.PSPath 

        # FilterLevel = 0 - Add the service to the list and go to the next one 
        if ($FilterLevel -eq 0) {
            [void]$ServiceListResult.Add($ServiceItem) 
            continue 
        }

        if ($Properties.ImagePath -and (-not ($Properties.ImagePath.trim() -eq ''))) {
            # FilterLevel = 1 - Add the service to the list of its ImagePath is not empty
            if ($FilterLevel -le 1) {
                [void]$ServiceListResult.Add($ServiceItem)
                continue 
            }

            if ($Properties.Type -gt 8) {
                # FilterLevel = 2 - Add the service to the list if it's not a driver 
                if ($FilterLevel -le 2) {
                    [void]$ServiceListResult.Add($ServiceItem) 
                    continue
                }

                if (-not (Test-IsKnownService -ServiceName $Properties.PSChildName)) {
                    # FilterLevel = 3 - Add the service if it's not a built-in Windows service 
                    if ($FilterLevel -le 3) {
                        [void]$ServiceListResult.Add($ServiceItem) 
                        continue
                    }
                }
            }
        } 
    }

    return $ServiceListResult
}

function Get-ModifiablePath {
    <#
        .SYNOPSIS
    
            Parses a passed string containing multiple possible file/folder paths and returns
            the file paths where the current user has modification rights.
    
            Author: @harmj0y
            License: BSD 3-Clause
    
        .DESCRIPTION
    
            Takes a complex path specification of an initial file/folder path with possible
            configuration files, 'tokenizes' the string in a number of possible ways, and
            enumerates the ACLs for each path that currently exists on the system. Any path that
            the current user has modification rights on is returned in a custom object that contains
            the modifiable path, associated permission set, and the IdentityReference with the specified
            rights. The SID of the current user and any group he/she are a part of are used as the
            comparison set against the parsed path DACLs.
    
        .PARAMETER Path
    
            The string path to parse for modifiable files. Required
    
        .PARAMETER LiteralPaths
    
            Switch. Treat all paths as literal (i.e. don't do 'tokenization').
    
        .EXAMPLE
    
            PS C:\> '"C:\Temp\blah.exe" -f "C:\Temp\config.ini"' | Get-ModifiablePath
    
            Path                       Permissions                IdentityReference
            ----                       -----------                -----------------
            C:\Temp\blah.exe           {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
            C:\Temp\config.ini         {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
    
        .EXAMPLE
    
            PS C:\> Get-ChildItem C:\Vuln\ -Recurse | Get-ModifiablePath
    
            Path                       Permissions                IdentityReference
            ----                       -----------                -----------------
            C:\Vuln\blah.bat           {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
            C:\Vuln\config.ini         {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
            ...
    #>
    
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$True)]
        [Alias('FullName')]
        [String[]]
        $Path,

        [Switch]
        $LiteralPaths
    )

    BEGIN {
        # # false positives ?
        # $Excludes = @("MsMpEng.exe", "NisSrv.exe")

        # from http://stackoverflow.com/questions/28029872/retrieving-security-descriptor-and-getting-number-for-filesystemrights
        $AccessMask = @{
            [uint32]'0x80000000' = 'GenericRead'
            [uint32]'0x40000000' = 'GenericWrite'
            [uint32]'0x20000000' = 'GenericExecute'
            [uint32]'0x10000000' = 'GenericAll'
            [uint32]'0x02000000' = 'MaximumAllowed'
            [uint32]'0x01000000' = 'AccessSystemSecurity'
            [uint32]'0x00100000' = 'Synchronize'
            [uint32]'0x00080000' = 'WriteOwner'
            [uint32]'0x00040000' = 'WriteDAC'
            [uint32]'0x00020000' = 'ReadControl'
            [uint32]'0x00010000' = 'Delete'
            [uint32]'0x00000100' = 'WriteAttributes'
            [uint32]'0x00000080' = 'ReadAttributes'
            [uint32]'0x00000040' = 'DeleteChild'
            [uint32]'0x00000020' = 'Execute/Traverse'
            [uint32]'0x00000010' = 'WriteExtendedAttributes'
            [uint32]'0x00000008' = 'ReadExtendedAttributes'
            [uint32]'0x00000004' = 'AppendData/AddSubdirectory'
            [uint32]'0x00000002' = 'WriteData/AddFile'
            [uint32]'0x00000001' = 'ReadData/ListDirectory'
        }

        $UserIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
        $CurrentUserSids = $UserIdentity.Groups | Select-Object -ExpandProperty Value
        $CurrentUserSids += $UserIdentity.User.Value

        $TranslatedIdentityReferences = @{}
    }

    PROCESS {

        ForEach($TargetPath in $Path) {

            $CandidatePaths = @()

            # possible separator character combinations
            $SeparationCharacterSets = @('"', "'", ' ', "`"'", '" ', "' ", "`"' ")

            if($PSBoundParameters['LiteralPaths']) {

                $TempPath = $([System.Environment]::ExpandEnvironmentVariables($TargetPath))

                if(Test-Path -Path $TempPath -ErrorAction SilentlyContinue) {
                    $CandidatePaths += Resolve-Path -Path $TempPath | Select-Object -ExpandProperty Path
                }
                else {
                    # if the path doesn't exist, check if the parent folder allows for modification
                    try {
                        $ParentPath = Split-Path $TempPath -Parent
                        if($ParentPath -and (Test-Path -Path $ParentPath -ErrorAction SilentlyContinue)) {
                            $CandidatePaths += Resolve-Path -Path $ParentPath -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path
                        }
                    }
                    catch {
                        # because Split-Path doesn't handle -ErrorAction SilentlyContinue nicely
                    }
                }
            }
            else {
                ForEach($SeparationCharacterSet in $SeparationCharacterSets) {
                    $TargetPath.Split($SeparationCharacterSet) | Where-Object {$_ -and ($_.trim() -ne '')} | ForEach-Object {

                        if(($SeparationCharacterSet -notmatch ' ')) {

                            $TempPath = $([System.Environment]::ExpandEnvironmentVariables($_)).Trim()

                            # if the path is actually an option like '/svc', skip it 
                            # it will prevent a lot of false positives but it might also skip vulnerable paths in some particular cases 
                            # though, it's more common to see options like '/svc' than file paths like '/ProgramData/something' in Windows 
                            if ($TempPath -Like "/*") { continue }

                            if($TempPath -and ($TempPath -ne '')) {
                                if(Test-Path -Path $TempPath -ErrorAction SilentlyContinue) {
                                    # if the path exists, resolve it and add it to the candidate list
                                    $CandidatePaths += Resolve-Path -Path $TempPath | Select-Object -ExpandProperty Path
                                }

                                else {
                                    # if the path doesn't exist, check if the parent folder allows for modification
                                    try {
                                        $ParentPath = (Split-Path -Path $TempPath -Parent).Trim()
                                        if($ParentPath -and ($ParentPath -ne '') -and (Test-Path -Path $ParentPath )) {
                                            $CandidatePaths += Resolve-Path -Path $ParentPath | Select-Object -ExpandProperty Path
                                        }
                                    }
                                    catch {
                                        # trap because Split-Path doesn't handle -ErrorAction SilentlyContinue nicely
                                    }
                                }
                            }
                        }
                        else {
                            # if the separator contains a space
                            $CandidatePaths += Resolve-Path -Path $([System.Environment]::ExpandEnvironmentVariables($_)) -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path | ForEach-Object {$_.Trim()} | Where-Object {($_ -ne '') -and (Test-Path -Path $_)}
                        }
                    }
                }
            }

            $CandidatePaths | Sort-Object -Unique | ForEach-Object {
                $CandidatePath = $_

                Get-Acl -Path $CandidatePath | Select-Object -ExpandProperty Access | Where-Object {($_.AccessControlType -match 'Allow')} | ForEach-Object {

                    $FileSystemRights = $_.FileSystemRights.value__

                    $Permissions = $AccessMask.Keys | Where-Object { $FileSystemRights -band $_ } | ForEach-Object { $accessMask[$_] }

                    # the set of permission types that allow for modification
                    $Comparison = Compare-Object -ReferenceObject $Permissions -DifferenceObject @('GenericWrite', 'GenericAll', 'MaximumAllowed', 'WriteOwner', 'WriteDAC', 'WriteData/AddFile', 'AppendData/AddSubdirectory') -IncludeEqual -ExcludeDifferent

                    if($Comparison) {
                        if ($_.IdentityReference -notmatch '^S-1-5.*' -and $_.IdentityReference -notmatch '^S-1-15-.*') {
                            if(-not ($TranslatedIdentityReferences[$_.IdentityReference])) {
                                # translate the IdentityReference if it's a username and not a SID
                                $IdentityUser = New-Object System.Security.Principal.NTAccount($_.IdentityReference)
                                $TranslatedIdentityReferences[$_.IdentityReference] = $IdentityUser.Translate([System.Security.Principal.SecurityIdentifier]) | Select-Object -ExpandProperty Value
                            }
                            $IdentitySID = $TranslatedIdentityReferences[$_.IdentityReference]
                        }
                        else {
                            $IdentitySID = $_.IdentityReference
                        }

                        if($CurrentUserSids -contains $IdentitySID) {
                            New-Object -TypeName PSObject -Property @{
                                ModifiablePath = $CandidatePath
                                IdentityReference = $_.IdentityReference
                                Permissions = $Permissions
                            }
                        }
                    }
                }
            }
        }
    }
}

function Get-ModifiableRegistryPath {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$True)]
        [String[]]
        $Path
    )

    BEGIN {
        # # false positives ?
        # $Excludes = @("MsMpEng.exe", "NisSrv.exe")

        # from http://stackoverflow.com/questions/28029872/retrieving-security-descriptor-and-getting-number-for-filesystemrights
        $AccessMask = @{
            [uint32]'0x80000000' = 'GenericRead'
            [uint32]'0x40000000' = 'GenericWrite'
            [uint32]'0x20000000' = 'GenericExecute'
            [uint32]'0x10000000' = 'GenericAll'
            [uint32]'0x02000000' = 'MaximumAllowed'
            [uint32]'0x01000000' = 'AccessSystemSecurity'
            [uint32]'0x00100000' = 'Synchronize'
            [uint32]'0x00080000' = 'WriteOwner'
            [uint32]'0x00040000' = 'WriteDAC'
            [uint32]'0x00020000' = 'ReadControl'
            [uint32]'0x00010000' = 'Delete'
            [uint32]'0x00000100' = 'WriteAttributes'
            [uint32]'0x00000080' = 'ReadAttributes'
            [uint32]'0x00000040' = 'DeleteChild'
            [uint32]'0x00000020' = 'Execute/Traverse'
            [uint32]'0x00000010' = 'WriteExtendedAttributes'
            [uint32]'0x00000008' = 'ReadExtendedAttributes'
            [uint32]'0x00000004' = 'AppendData/AddSubdirectory'
            [uint32]'0x00000002' = 'WriteData/AddFile'
            [uint32]'0x00000001' = 'ReadData/ListDirectory'
        }

        $UserIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
        $CurrentUserSids = $UserIdentity.Groups | Select-Object -ExpandProperty Value
        $CurrentUserSids += $UserIdentity.User.Value

        $TranslatedIdentityReferences = @{}
    }

    PROCESS {
        $KeyAcl = Get-Acl -Path $Path -ErrorAction SilentlyContinue -ErrorVariable GetAclError
        if (-not $GetAclError) {
            $KeyAcl | Select-Object -ExpandProperty Access | Where-Object {($_.AccessControlType -match 'Allow')} | ForEach-Object {

                $RegistryRights = $_.RegistryRights.value__

                $Permissions = $AccessMask.Keys | Where-Object { $RegistryRights -band $_ } | ForEach-Object { $accessMask[$_] }

                # the set of permission types that allow for modification
                $Comparison = Compare-Object -ReferenceObject $Permissions -DifferenceObject @('GenericWrite', 'GenericAll', 'MaximumAllowed', 'WriteOwner', 'WriteDAC', 'WriteData/AddFile', 'AppendData/AddSubdirectory') -IncludeEqual -ExcludeDifferent

                if($Comparison) {
                    if ($_.IdentityReference -notmatch '^S-1-5.*') {
                        if(-not ($TranslatedIdentityReferences[$_.IdentityReference])) {
                            # translate the IdentityReference if it's a username and not a SID
                            $IdentityUser = New-Object System.Security.Principal.NTAccount($_.IdentityReference)
                            $TranslatedIdentityReferences[$_.IdentityReference] = $IdentityUser.Translate([System.Security.Principal.SecurityIdentifier]) | Select-Object -ExpandProperty Value
                        }
                        $IdentitySID = $TranslatedIdentityReferences[$_.IdentityReference]
                    }
                    else {
                        $IdentitySID = $_.IdentityReference
                    }

                    if($CurrentUserSids -contains $IdentitySID) {
                        New-Object -TypeName PSObject -Property @{
                            ModifiablePath = $Path
                            IdentityReference = $_.IdentityReference
                            Permissions = $Permissions
                        }
                    }
                }
            }
        }
    } 
}

function Get-ServiceReadControlHandle {
    [OutputType([IntPtr])]
    param (
        [Parameter(Mandatory=$True, ValueFromPipeline=$True)]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ $_ -as 'ServiceProcess.ServiceController' })]
        $Service
    )

    $GetServiceHandle = [ServiceProcess.ServiceController].GetMethod('GetServiceHandle', [Reflection.BindingFlags] 'Instance, NonPublic')
    $ReadControl = 0x00020000
    $RawHandle = $GetServiceHandle.Invoke($Service, @($ReadControl))
    $RawHandle
}

function Add-ServiceDacl {
    <#
    .SYNOPSIS
    Adds a Dacl field to a service object returned by Get-Service.

    Author: Matthew Graeber (@mattifestation)
    License: BSD 3-Clause

    .DESCRIPTION
    Takes one or more ServiceProcess.ServiceController objects on the pipeline and adds a
    Dacl field to each object. It does this by opening a handle with ReadControl for the
    service with using the GetServiceHandle Win32 API call and then uses
    QueryServiceObjectSecurity to retrieve a copy of the security descriptor for the service.

    .PARAMETER Name
    An array of one or more service names to add a service Dacl for. Passable on the pipeline.

    .EXAMPLE
    PS C:\> Get-Service | Add-ServiceDacl

    Add Dacls for every service the current user can read.

    .EXAMPLE
    PS C:\> Get-Service -Name VMTools | Add-ServiceDacl

    Add the Dacl to the VMTools service object.

    .OUTPUTS
    ServiceProcess.ServiceController

    .LINK
    https://rohnspowershellblog.wordpress.com/2013/03/19/viewing-service-acls/
    #>

    [OutputType('ServiceProcess.ServiceController')]
    param (
        [Parameter(Position=0, Mandatory=$True, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$True)]
        [Alias('ServiceName')]
        [String[]]
        [ValidateNotNullOrEmpty()]
        $Name
    )

    BEGIN {
        filter Local:Get-ServiceReadControlHandle {
            [OutputType([IntPtr])]
            param (
                [Parameter(Mandatory=$True, ValueFromPipeline=$True)]
                [ValidateNotNullOrEmpty()]
                [ValidateScript({ $_ -as 'ServiceProcess.ServiceController' })]
                $Service
            )
            Add-Type -AssemblyName System.ServiceProcess # ServiceProcess is not loaded by default  
            $GetServiceHandle = [ServiceProcess.ServiceController].GetMethod('GetServiceHandle', [Reflection.BindingFlags] 'Instance, NonPublic')
            $ReadControl = 0x00020000
            $RawHandle = $GetServiceHandle.Invoke($Service, @($ReadControl))
            $RawHandle
        }
    }

    PROCESS {
        ForEach($ServiceName in $Name) {

            $IndividualService = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue -ErrorVariable GetServiceError
            if (-not $GetServiceError) {

                try {
                    $ServiceHandle = Get-ServiceReadControlHandle -Service $IndividualService
                }
                catch {
                    $ServiceHandle = $Null
                }

                if ($ServiceHandle -and ($ServiceHandle -ne [IntPtr]::Zero)) {
                    $SizeNeeded = 0

                    $Result = [PrivescCheck.Win32]::QueryServiceObjectSecurity($ServiceHandle, [Security.AccessControl.SecurityInfos]::DiscretionaryAcl, @(), 0, [Ref] $SizeNeeded)
                    $LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()

                    # 122 == The data area passed to a system call is too small
                    if ((-not $Result) -and ($LastError -eq 122) -and ($SizeNeeded -gt 0)) {
                        $BinarySecurityDescriptor = New-Object Byte[]($SizeNeeded)

                        $Result = [PrivescCheck.Win32]::QueryServiceObjectSecurity($ServiceHandle, [Security.AccessControl.SecurityInfos]::DiscretionaryAcl, $BinarySecurityDescriptor, $BinarySecurityDescriptor.Count, [Ref] $SizeNeeded)
                        $LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()

                        if ($Result) {
                            
                            $RawSecurityDescriptor = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $BinarySecurityDescriptor, 0

                            $Dacl = $RawSecurityDescriptor.DiscretionaryAcl | ForEach-Object {
                                Add-Member -InputObject $_ -MemberType NoteProperty -Name AccessRights -Value $([PrivescCheck.Win32+ServiceAccessFlags] $_.AccessMask) -PassThru
                            }

                            Add-Member -InputObject $IndividualService -MemberType NoteProperty -Name Dacl -Value $Dacl -PassThru
                        }
                    }

                    $Null = [PrivescCheck.Win32]::CloseServiceHandle($ServiceHandle)
                }
            }
        }
    }
}
#endregion Helpers 


# ----------------------------------------------------------------
# Checks  
# ----------------------------------------------------------------
#region Checks 

# ----------------------------------------------------------------
# BEGIN REGISTRY SETTINGS   
# ----------------------------------------------------------------
function Invoke-UacCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    PS C:\> Invoke-UacCheck | fl 
    [!] UAC is enabled on this machine.

    Enabled : True
    
    .NOTES
    We can see whether UAC is eanbled by querying the value 'EnableLUA' of the following registry key.
    UAC was formerly known as Limited User Account (LUA), hence the name 'EnableLUA'. Didn't know that. :)

    C:\>reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA

    HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System
        EnableLUA    REG_DWORD    0x1
    
    0x0 = Disabled - 0x1 = Enabled
    #>
    
    [CmdletBinding()]Param()

    $UacEnabled = $False 

    $RegPath = "Registry::HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System"
    $Item = Get-ItemProperty -Path $RegPath -ErrorAction SilentlyContinue -ErrorVariable GetItemPropertyError
    if (-not $GetItemPropertyError) {
        if ($Item.EnableLUA -eq 1) {
            $UacEnabled = $True
        } 
    } else {
        Write-Verbose -Message "Error while querying '$RegPath'"
    }

    $UacResult = New-Object -TypeName PSObject
    $UacResult | Add-Member -MemberType "NoteProperty" -Name "Enabled" -Value $UacEnabled

    if ($UacResult.Enabled) {
        Write-Message -Level Warning "UAC is enabled on this machine."
    } else {
        Write-Message -Level Success "UAC is disabled on this machine."
    }

    return $UacResult
}

function Invoke-LapsCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    PS C:\> Invoke-LapsCheck | fl
    [+] LAPS isn't enabled on this machine.

    Enabled : False

    .NOTES
    TODO: General notes
    #>
    
    [CmdletBinding()]Param()
    
    $RegPath = "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft Services\AdmPwd"

    $LapsEnabled = $False 

    $Item = Get-ItemProperty -Path $RegPath -ErrorAction SilentlyContinue -ErrorVariable GetItemPropertyError 
    if (-not $GetItemPropertyError) {
        if ($Item.AdmPwdEnabled -eq 1) {
            $LapsEnabled = $True 
        }
    }

    $LapsResult = New-Object -TypeName PSObject 
    $LapsResult | Add-Member -MemberType "NoteProperty" -Name "Enabled" -Value $LapsEnabled

    if ($LapsResult.Enabled) {
        Write-Message -Level Warning "LAPS is enabled on this machine."
    } else {
        Write-Message -Level Success "LAPS isn't enabled on this machine."
    }

    return $LapsResult
}

function Invoke-PowershellTranscriptionCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    PS C:\> Invoke-PowershellTranscriptionCheck | fl
    [!] PowerShell Transription is not configured.

    .EXAMPLE
    PS C:\> Invoke-PowershellTranscriptionCheck | fl
    [*] PowerShell Transription is configured.
        [!] EnableTranscripting:    1 - Enabled
        [*] EnableInvocationHeader: 1 - Enabled
        [*] OutputDirectory:        'C:\Transcripts'

    EnableTranscripting    : 1
    EnableInvocationHeader : 1
    OutputDirectory        : C:\Transcripts
    
    .NOTES
    If PowerShell Transcription is configured, the settings can be found here:

    C:\>reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription

    HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription
        EnableTranscripting    REG_DWORD    0x1
        OutputDirectory    REG_SZ    C:\Transcripts
        EnableInvocationHeader    REG_DWORD    0x1
    
    To enable PowerShell Transcription:
    Group Policy Editor > Administrative Templates > Windows Components > Windows PowerShell > PowerShell Transcription
    Set an output directory and set the policy as Enabled
    #>
    
    [CmdletBinding()]Param()

    $PowershellTranscriptionResult = New-Object -TypeName PSObject

    $RegPath = "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription"

    $Item = Get-ItemProperty -Path $RegPath -ErrorAction SilentlyContinue -ErrorVariable GetItemPropertyError 
    if (-not $GetItemPropertyError) {
        # PowerShell Transcription is configured  
        $PowershellTranscriptionResult | Add-Member -MemberType "NoteProperty" -Name "EnableTranscripting" -Value $Item.EnableTranscripting
        $PowershellTranscriptionResult | Add-Member -MemberType "NoteProperty" -Name "EnableInvocationHeader" -Value $Item.EnableInvocationHeader
        $PowershellTranscriptionResult | Add-Member -MemberType "NoteProperty" -Name "OutputDirectory" -Value $Item.OutputDirectory
    } else {
        # PowerShell Transcription is not configured 
        $PowershellTranscriptionResult = $Null 
    }

    if ($PowershellTranscriptionResult) {
        Write-Message -Level Info "PowerShell Transription is configured."
        $global:IndentLevel += 1
        if ($PowershellTranscriptionResult.EnableTranscripting -eq 1) {
            Write-Message -Level Warning "PowerShell Transription is enabled."
            Write-Message -Level Info "EnableTranscripting:    $($PowershellTranscriptionResult.EnableTranscripting)"
        } else {
            Write-Message -Level Success "PowerShell Transription is disabled."
            Write-Message -Level Info "EnableTranscripting:    $($PowershellTranscriptionResult.EnableTranscripting)"
        }
        Write-Message -Level Info "EnableInvocationHeader: $($PowershellTranscriptionResult.EnableInvocationHeader)"
        Write-Message -Level Info "OutputDirectory:        $($PowershellTranscriptionResult.OutputDirectory)"
        $global:IndentLevel -= 1
    } else {
        Write-Message -Level Warning "PowerShell Transription is not configured."
    }

    return $PowershellTranscriptionResult
}

function Invoke-RegistryAlwaysInstallElevatedCheck {
   
    [CmdletBinding()]Param()

    $RegistryAlwaysInstallElevatedResult = New-Object -TypeName System.Collections.ArrayList

    if (Test-Path -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer" -ErrorAction SilentlyContinue) {

        $HKLMval = (Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue)
        if ($HKLMval.AlwaysInstallElevated -and ($HKLMval.AlwaysInstallElevated -ne 0)){
            # HKLM:AlwaysInstallElevated is enabled 
            $RegistryAlwaysInstallElevatedItem = New-Object -TypeName PSObject 
            $RegistryAlwaysInstallElevatedItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer"
            $RegistryAlwaysInstallElevatedItem | Add-Member -MemberType "NoteProperty" -Name "Value" -Value $HKLMval.AlwaysInstallElevated 
            [void]$RegistryAlwaysInstallElevatedResul.Add($RegistryAlwaysInstallElevatedItem)
        } 

        $HKCUval = (Get-ItemProperty -Path "Registry::HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue)
        if ($HKCUval.AlwaysInstallElevated -and ($HKCUval.AlwaysInstallElevated -ne 0)){
            # HKCU:AlwaysInstallElevated is enabled 
            $RegistryAlwaysInstallElevatedItem = New-Object -TypeName PSObject
            $RegistryAlwaysInstallElevatedItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer"
            $RegistryAlwaysInstallElevatedItem | Add-Member -MemberType "NoteProperty" -Name "Value" -Value $HKLMval.AlwaysInstallElevated 
            [void]$RegistryAlwaysInstallElevatedResul.Add($RegistryAlwaysInstallElevatedItem)
        } 
    } 

    if (([object[]]$RegistryAlwaysInstallElevatedResult).Length -gt 0) {
        Write-Message -Level Success "The 'AlwaysInstallElevated' key exists and is enabled."
        ForEach ($Result in $RegistryAlwaysInstallElevatedResult) {
            $global:IndentLevel += 1
            Write-Message -Level Success "Path: $($Result.Name) - Value: $($Result.Value)"
            $global:IndentLevel -= 1
        }
    } else {
        Write-Message -Level Warning "The key either doesn't exist or is not enabled."
    }

    return $RegistryAlwaysInstallElevatedResult
}
# ----------------------------------------------------------------
# END REGISTRY SETTINGS   
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN MISC   
# ----------------------------------------------------------------
function Invoke-SystemInfoCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: 
    https://techthoughts.info/windows-version-numbers/
    #>
    
    [CmdletBinding()] param()

    $Item = Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion" 

    $SystemInfoResult = New-Object -TypeName PSObject 

    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "ProductName" -Value $Item.ProductName
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Major" -Value $Item.CurrentMajorVersionNumber
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Minor" -Value $Item.CurrentMinorVersionNumber
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Release" -Value $Item.ReleaseId
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Build" -Value $Item.CurrentBuild
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Revision" -Value $Item.UBR

    $FullVersion = "$($Item.CurrentMajorVersionNumber).$($Item.CurrentMinorVersionNumber).$($Item.CurrentBuild) Version $($Item.ReleaseId) ($($Item.CurrentBuild).$($Item.UBR))"

    Write-Message -Level Info "OS Name: $($Item.ProductName)"
    Write-Message -Level Info "OS Version: $($FullVersion)"
    
    return $SystemInfoResult
}

function Invoke-SystemStartupHistoryCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .PARAMETER TimeSpanInDays
    TODO: Parameter description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: 
    Event ID 6005: The Event log service was started, i.e. system startup theoretically.
    #>
    
    [CmdletBinding()] param(
        [int]
        $TimeSpanInDays = 31
    )

    $SystemStartupHistoryResult = New-Object -TypeName System.Collections.ArrayList

    $StartDate = (Get-Date).AddDays(-$TimeSpanInDays)
    $EndDate = Get-Date
    $TimeSpan = New-TimeSpan -Start $StartDate -End $EndDate

    $StartupEvents = Get-EventLog -LogName "System" -EntryType "Information" -After $StartDate -Before $EndDate | Where-Object {$_.EventID -eq 6005}

    ForEach ($Event in $StartupEvents) {
        $SystemStartupHistoryItem = New-Object -TypeName PSObject 
        $SystemStartupHistoryItem | Add-Member -MemberType "NoteProperty" -Name "Time" -Value "$(Convert-DateToString -Date $Event.TimeGenerated)"
        $SystemStartupHistoryItem | Add-Member -MemberType "NoteProperty" -Name "Message" -Value "$($Event.Message)"
        [void]$SystemStartupHistoryResult.Add($SystemStartupHistoryItem)
    }

    if (([object[]]$SystemStartupHistoryResult).Length -gt 0) {
        
        Write-Message -Level Info "Found $(([object[]]$SystemStartupHistoryResult).Length) startup event(s) in the last $($TimeSpan.Days) days."
        Write-Message -Level Info "Last startup time was: $($SystemStartupHistoryResult[0].Time)"

        if ($StartupEvents.Length -gt 10) {
            Write-Message -Level Success "The machine seems to be frequently rebooted. Showing last 10 events."
            For ($i = 0; $i -lt 10; $i++) {
                $global:IndentLevel +=1
                Write-Message -Level Info "Startup event: $(Convert-DateToString -Date $StartupEvents[$i].TimeGenerated)"
                $global:IndentLevel -=1
            }
        } 

    } else {
        Write-Message -Level Warning "Didn't find any startup event in the last $($TimeSpan.Days) days."

        $LastStartupEvent = Get-EventLog -LogName "System" -EntryType "Information" -Newest 1 -InstanceId 2147489653

        if ($LastStartupEvent) {
            Write-Message -Level Info "Last startup time was: $(Convert-DateToString -Date $LastStartupEvent.TimeGenerated)."
        }
    }

    return $SystemStartupHistoryResult
}

function Invoke-SystemDrivesCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>
    
    [CmdletBinding()] param()

    $Drives = Get-PSDrive -PSProvider "FileSystem"

    Write-Message -Level Info "Found $($Drives.Length) drives."
    ForEach ($Drive in $Drives) {
        $global:IndentLevel += 1
        Write-Message -Level Info "$($Drive.Root) - Display name: '$($Drive.DisplayRoot)' - Description: '$($Drive.Description)'"
        $global:IndentLevel -= 1
    }

    return $Drives 
}

function Invoke-LocalAdminGroupCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: 
    S-1-5-32-544 = SID of the local admin group 
    S-1-5-21-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxx-500 = SID of the default local admin 
    #>

    [CmdletBinding()] param()

    $LocalAdminGroupResult = New-Object System.Collections.ArrayList 

    $LocalAdminGroup = Get-LocalGroup -SID "S-1-5-32-544" -ErrorAction SilentlyContinue 
    $LocalAdmins = Get-LocalGroupMember -Group $LocalAdminGroup -ErrorAction SilentlyContinue -ErrorVariable GetLocalGroupMemberError

    if (-not $GetLocalGroupMemberError) {
        $GroupClassName = $LocalAdminGroup.ObjectClass 

        Write-Message -Level Info "The local group '$($LocalAdminGroup.Name)' has $($LocalAdmins.Length) members (users/groups)."

        ForEach ($LocalAdmin in $LocalAdmins) {
            $global:IndentLevel += 1
            $ItemName = ""
            $ItemType = $LocalAdmin.ObjectClass
            $ItemIsLocal = $True 
            $ItemIsEnabled = $True 
            $LocalAdminGroupResultItem = New-Object -TypeName PSObject
            if  ($LocalAdmin.PrincipalSource -eq "Local") {
                $ItemIsLocal = $True
                if ($LocalAdmin.ObjectClass -eq $GroupClassName) {
                    $LocalGroup = Get-LocalGroup -SID $LocalAdmin.SID 
                    $ItemName = $LocalGroup.Name
                    Write-Message -Level Info "Local group '$($LocalGroup.Name)'."
                } else {
                    $LocalAccount = Get-LocalUser -SID $LocalAdmin.SID 
                    $ItemName = $LocalAccount.Name
                    if ($LocalAccount.Enabled) {
                        $ItemIsEnabled = $True 
                        Write-Message -Level Info "Local user '$($LocalAccount.Name)'."
                    } else {
                        $ItemIsEnabled = $False 
                        Write-Message -Level Warning "Local user '$($LocalAccount.Name)' is disabled."
                    }
                }
            } else {
                $ItemIsLocal = $False
                $ItemName = $LocalAdmin.Name
                if ($LocalAdmin.ObjectClass -eq $GroupClassName) {
                    Write-Message -Level Info "Domain group/user '$($LocalAdmin.Name)'."
                }
            }

            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $ItemName
            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "Type" -Value $ItemType
            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "IsLocal" -Value $ItemIsLocal  
            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "IsEnabled" -Value $ItemIsEnabled 
            [void]$LocalAdminGroupResult.Add($LocalAdminGroupResultItem)

            $global:IndentLevel -= 1
        }
    } else {
        Write-Message -Level Error "An unknown error occurred."
        Write-Verbose -Message $GetLocalGroupMemberError.Exception 
    }

    return $LocalAdminGroupResult
}

function Invoke-MachineRoleCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: 
    WinNT = workstation
    LanmanNT = domain controller
    ServerNT = server
    #>
    
    [CmdletBinding()] param()

    $MachineRoleResult = New-Object -TypeName PSObject 

    $Item = Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\ProductOptions"
    
    $RoleFriendlyName = ""

    if ($Item.ProductType -eq "WinNT") {
        $RoleFriendlyName = "WorkStation"
    } elseif ($Item.ProducType -eq "LanmanNT") {
        $RoleFriendlyName = "Domain Controller"
    } elseif ($Item.ProductType -eq "ServerNT") {
        $RoleFriendlyName = "Server"
    } 

    if (($RoleFriendlyName -eq "")) {
        $MachineRoleResult = $Null 
    } else {
        $MachineRoleResult | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Item.ProductType
        $MachineRoleResult | Add-Member -MemberType "NoteProperty" -Name "Role" -Value $RoleFriendlyName
    }

    if ($MachineRoleResult) {
        Write-Message -Level Info "Machine type: '$($RoleFriendlyName)'"
    } else {
        Write-Message -Level Warning "Machine role is unknown."
    }

    return $MachineRoleResult
}

function Invoke-WindowsUpdateCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>
    
    [CmdletBinding()] param()

    $WindowsUpdateResult = New-Object -TypeName PSObject 

    $WindowsUpdate = (New-Object -ComObject "Microsoft.Update.AutoUpdate").Results

    $EndDate = Get-Date 
    $StartDate = $WindowsUpdate.LastInstallationSuccessDate
    $TimeSpan = New-TimeSpan -Start $StartDate -End $EndDate 

    if ($TimeSpan.Days -ge 30) {
        $WindowsUpdateResult = $WindowsUpdate
    } else {
        $WindowsUpdateResult = $Null 
    }

    Write-Message -Level Info "Last successful update time: $(Convert-DateToString -Date $WindowsUpdate.LastInstallationSuccessDate)"
    
    if ($WindowsUpdateResult) {
        Write-Message -Level Success "Last update is more than 1 month old."
    } else {
        Write-Message -Level Warning "The machine seems to be quite up-to-date."        
    }

    return $WindowsUpdateResult
}

# ----------------------------------------------------------------
# END MISC   
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN PRIVILEGES   
# ----------------------------------------------------------------
function Invoke-UserPrivilegesCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: 
    TODO: Rewrite this to avoid a call to an external tool 
    TODO: Add a description on how to exploit each priv 

    Interesting privileges 
        - SeAssignPrimaryTokenPrivilege
        - SeImpersonatePrivilege
        - SeCreateTokenPrivilege
        - SeDebugPrivilege
        - SeLoadDriverPrivilege
        - SeRestorePrivilege
        - SeTakeOwnershipPrivilege
    #>

    [CmdletBinding()] param()

    $UserPrivilegesResult = New-Object -TypeName System.Collections.ArrayList

    $Username = "$($env:USERDOMAIN)\$($env:USERNAME)"

    $Privileges = "SeAssignPrimaryTokenPrivilege", "SeImpersonatePrivilege", "SeCreateTokenPrivilege", "SeDebugPrivilege", "SeLoadDriverPrivilege", "SeRestorePrivilege", "SeTakeOwnershipPrivilege", "SeTcbPrivilege", "SeShutdownPrivilege", "SeBackupPrivilege"

    $Output = (& whoami /priv | Out-String) 
        
    $Lines = $Output.Split("`n")
    ForEach ($Line in $Lines) {
        If ($Line -Like "*Se*Privilege*") {
            $Priv = $Line.Split(' ')[0]
            if ($Privileges -contains $Priv) {
                $UserPrivilegeItem = New-Object -TypeName PSObject 
                $UserPrivilegeItem | Add-Member -MemberType "NoteProperty" -Name "Username" -Value $Username
                $UserPrivilegeItem | Add-Member -MemberType "NoteProperty" -Name "Privilege" -Value $Priv
                $UserPrivilegesResult.Add([object]$UserPrivilegeItem)
            }
        }
    }

    if (([object[]]$UserPrivilegesResult).Length -gt 0) {
        Write-Message -Level Info "User '$($Username)' user has $(([object[]]$UserPrivilegesResult).Length) potentially interesting privilege(s)."
        $global:IndentLevel += 1
        ForEach ($Result in $UserPrivilegesResult) {
            Write-Message -Level Success "$($Result.Privilege)"
        }
        $global:IndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any interesting privilege."
    }

    return $UserPrivilegesResult
}
# ----------------------------------------------------------------
# END PRIVILEGES    
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN CREDENTIALS     
# ----------------------------------------------------------------
function Invoke-WinlogonCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>

    [CmdletBinding()] param()

    #$WinlogonResult = New-Object -TypeName PSObject 
    $WinlogonResult = New-Object -TypeName System.Collections.ArrayList
    
    $Item = Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"

    if ($Item.DefaultDomainName -Or $Item.DefaultUserName -Or $Item.DefaultPassword) {
        $WinlogonItem = New-Object -TypeName PSObject 
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Domain" -Value $Item.DefaultDomainName
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Username" -Value $Item.DefaultUserName
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Password" -Value $Item.DefaultPassword
        [void]$WinlogonResult.Add($WinlogonItem)
    } 

    if ($Item.AltDefaultDomainName -Or $Item.AltDefaultUserName -Or $Item.AltDefaultPassword) {
        $WinlogonItem = New-Object -TypeName PSObject 
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Domain" -Value $Item.AltDefaultDomainName
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Username" -Value $Item.AltDefaultUserName
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Password" -Value $Item.AltDefaultPassword
        [void]$WinlogonResult.Add($WinlogonItem)
    }

    if (([object[]]$WinlogonResult).Length -gt 0) {
        Write-Message -Level Info "Found $(([object[]]$WinlogonResult).Length) credential(s)."
        $global:IndentLevel += 1
        ForEach ($Result in $WinlogonResult) {
            $OutString = ""
            if ($Result.Domain) { $OutString += "$($Result.Domain)\" } else { $OutString += "(null)\" }
            if ($Result.Username) { $OutString += "$($Result.Username)" } else { $OutString += "(null)" }
            if ($Result.Password) { $OutString += ":$($Result.Password)"} else { $OutString += ":(null)" }

            if ($Result.Password) {
                Write-Message -Level Success $OutString
            } else { 
                Write-Message -Level Info $OutString
            }
        }
        $global:IndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find anything."
    }

    return $WinlogonResult
}

function Invoke-CredentialFilesCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: 
    Get file content with https://github.com/AlessandroZ/LaZagne ???
    #>
    
    [CmdletBinding()] param()

    function Get-CredentialFiles {
        [CmdletBinding()] param(
            [string]
            $Path 
        )
        $Result = New-Object System.Collections.ArrayList
        $Items = Get-ChildItem -Hidden -Path $Path -ErrorAction SilentlyContinue -ErrorVariable Errors 
        if (-not $Errors) {
            ForEach ($Item in $Items) {
                $FullPath = Join-Path -Path $Path -ChildPath $Item.Name 
                $FileObject = New-Object -TypeName PSObject 
                $FileObject | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Item.Name
                $FileObject | Add-Member -MemberType "NoteProperty" -Name "FullPath" -Value $FullPath
                [void]$Result.Add($FileObject)
            }
        }
        return $Result
    }

    $CredentialFilesResult = New-Object -TypeName System.Collections.ArrayList

    $PathLocalAppData = Join-Path -Path $env:LOCALAPPDATA -ChildPath "Microsoft\Credentials"
    $PathAppData = Join-Path -Path $env:APPDATA -ChildPath "Microsoft\Credentials"

    $Items = Get-CredentialFiles -Path $PathLocalAppData
    if ($Items) {
        [void]$CredentialFilesResult.AddRange([object[]]$Items)
    }

    $Items = Get-CredentialFiles -Path $PathAppData
    if ($Items) {
        [void]$CredentialFilesResult.AddRange([object[]]$Items)
    }

    if (([object[]]$CredentialFilesResult).Length -gt 0) {
        Write-Message -Level Info "Found $(([object[]]$CredentialFilesResult).Length) credential files"
        $global:IndentLevel += 1
        ForEach ($CredentialFile in $CredentialFilesResult) {
            Write-Message -Level Info "$($CredentialFile.FullPath)"
        }
        $global:IndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any credential file."
    }

    return $CredentialFilesResult
}
# ----------------------------------------------------------------
# END CREDENTIALS     
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN SENSITIVE FILES 
# ----------------------------------------------------------------
function Invoke-SamBackupFilesCheck {
    
    [CmdletBinding()] param()

    $SamBackupFiles = New-Object System.Collections.ArrayList

    $ArrayOfPaths = New-Object System.Collections.ArrayList 
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "repair\SAM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\RegBack\SAM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\SAM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "repair\system"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\SYSTEM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\RegBack\system"))

    ForEach ($Path in [string[]]$ArrayOfPaths) {
        if (Test-Path -Path $Path -ErrorAction SilentlyContinue) { 
            $SamBackupFile = New-Object -TypeName PSObject   
            Get-Content -Path $Path -ErrorAction SilentlyContinue -ErrorVariable GetContentError | Out-Null 
            if (-not $GetContentError) {
                $SamBackupFile | Add-Member -MemberType "NoteProperty" -Name "Path" -Value $Path 
                [void]$SamBackupFiles.Add($SamBackupFile) 
            } 
        }
    }

    if (([object[]]$SamBackupFiles).Length -gt 0) {
        Write-Message -Level Info "Found $(([object[]]$SamBackupFiles).Length) readable file(s)."
        $global:IndentLevel +=1
        ForEach ($File in $SamBackupFiles) {
            Write-Message -Level Success "File: $($File.Path)"
        }
        $global:IndentLevel -=1
    } else {
        Write-Message -Level Warning "Didn't find any readable file."
    }

    return $SamBackupFiles
}
# ----------------------------------------------------------------
# END SENSITIVE FILES 
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN INSTALLED PROGRAMS   
# ----------------------------------------------------------------
function Invoke-InstalledProgramsCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>
    
    [CmdletBinding()] param()

    $InstalledProgramsResult = New-Object System.Collections.ArrayList 

    $Items = Get-InstalledPrograms -Filtered

    ForEach ($Item in $Items) {
        $CurrentFileName = $Item.Name 
        $CurrentFileFullname = $Item.FullName
        $AppItem = New-Object -TypeName PSObject 
        $AppItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $CurrentFileName
        $AppItem | Add-Member -MemberType "NoteProperty" -Name "FullPath" -Value $CurrentFileFullname
        [void]$InstalledProgramsResult.Add($AppItem)
    }

    $InstalledProgramsResultLen = ([object[]]$InstalledProgramsResult).Length
    if ($InstalledProgramsResultLen -gt 0) {
        Write-Message -Level Info "Found $(([object[]]$InstalledProgramsResult).Length) third-party application(s)."
        $global:IndentLevel += 1
        ForEach ($Result in $InstalledProgramsResult) {
            Write-Message -Level Info "Application: $($Result.Name) - Path: $($Result.FullPath)"
        }
        $global:IndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any third-party application."
    }
    
    return $InstalledProgramsResult
}

function Invoke-ModifiableProgramsCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>
    
    [CmdletBinding()] param()

    $ModifiableProgramsResult = New-Object -TypeName System.Collections.ArrayList

    #$ModifiablePaths = New-Object -TypeName System.Collections.ArrayList
    $Items = Get-InstalledPrograms -Filtered

    Write-Message -Level Info "Searching for modifiable files/folders in $(([object[]]$Items).Length) applications..."

    $global:IndentLevel += 1
    ForEach ($Item in $Items) {
        $SearchPath = New-Object -TypeName System.Collections.ArrayList
        [void]$SearchPath.Add([string]$(Join-Path -Path $Item.FullName -ChildPath "\*")) # Do this to avoid the use of -Depth which is PSH5+
        [void]$SearchPath.Add([string]$(Join-Path -Path $Item.FullName -ChildPath "\*\*")) # Do this to avoid the use of -Depth which is PSH5+
        $ChildItems = Get-ChildItem -Path $SearchPath -ErrorAction SilentlyContinue -ErrorVariable GetChildItemError # Do this to avoid the use of -Depth which is PSH5+
        #$ChildItems = $Item | Get-ChildItem -Recurse -Depth 2 -ErrorAction SilentlyContinue -ErrorVariable GetChildItemError 
        if (-not $GetChildItemError) {
            $ChildItems | ForEach-Object {
                if ($_ -is [System.IO.DirectoryInfo]) {
                    $IsDirectory = $True
                    $GetModifiablePathsResult = $_ | Get-ModifiablePath -LiteralPaths
                    if ($GetModifiablePathsResult) {
                        $ModifiableProgram = New-Object -TypeName PSObject 
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "ModifiablePath" -Value $GetModifiablePathsResult[0].ModifiablePath 
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IsDirectory" -Value $IsDirectory
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IdentityReference" -Value $GetModifiablePathsResult[0].IdentityReference 
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "Permissions" -Value $GetModifiablePathsResult[0].Permissions 
                        [void]$ModifiableProgramsResult.Add([object]$ModifiableProgram)
                        Write-Message -Level Success "Found modifiable directory: $($_.FullName)"
                    }
                } else {
                    $IsDirectory = $False
                    # Check only .exe and .dll ???
                    # TODO: maybe consider other extensions 
                    if ($_.FullName -Like "*.exe" -or $_.FullName -Like "*.dll") {
                        $GetModifiablePathsResult = $_ | Get-ModifiablePath -LiteralPaths
                        ForEach($Result in $GetModifiablePathsResult) {
                            $ModifiableProgram = New-Object -TypeName PSObject 
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "ModifiablePath" -Value $Result.ModifiablePath 
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IsDirectory" -Value $IsDirectory
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IdentityReference" -Value $Result.IdentityReference 
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "Permissions" -Value $Result.Permissions 
                            [void]$ModifiableProgramsResult.Add([object]$ModifiableProgram)
                            Write-Message -Level Success "Found modifiable file: $($_.FullName)"
                        }
                    }
                }
            }
        }
    }
    $global:IndentLevel -= 1

    if (([object[]]$ModifiableProgramsResult).Length -eq 0) {
        Write-Message -Level Warning "Didn't find any modifiable path."
    }

    return $ModifiableProgramsResult
}
# ----------------------------------------------------------------
# END INSTALLED PROGRAMS   
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN SERVICES   
# ----------------------------------------------------------------
function Write-ServiceStatus {
    [CmdletBinding()] param(
        [object]
        $Service
    )

    Write-Message -Level Success "Service: '$($Service.Name)' ($($Service.DisplayName)) running as '$($Service.User)' (StartMode: $($Service.StartMode))"
    Write-Message -Level Info "Image path: $($Service.ImagePath)"
    Write-Message -Level Info "Status: $($Service.Status)"

    if ($Service.Status -eq "Running") {
        if ($Service.UserCanRestart) {
            Write-Message -Level Success "The current user can restart this service."
        } else {
            Write-Message -Level Warning "The current user cannot restart this service."
        }
    } elseif ($Service.Status -eq "Stopped") {
        if ($Service.UserCanStart) {
            Write-Message -Level Success "The current user can start this service."
        } else {
            Write-Message -Level Warning "The current user cannot start this service."
        }
    }
}

function Test-ServiceDaclPermission {
    <#
    .SYNOPSIS

    Tests one or more passed services or service names against a given permission set,
    returning the service objects where the current user have the specified permissions.

    Author: @harmj0y, Matthew Graeber (@mattifestation)
    License: BSD 3-Clause

    .DESCRIPTION

    Takes a service Name or a ServiceProcess.ServiceController on the pipeline, and first adds
    a service Dacl to the service object with Add-ServiceDacl. All group SIDs for the current
    user are enumerated services where the user has some type of permission are filtered. The
    services are then filtered against a specified set of permissions, and services where the
    current user have the specified permissions are returned.

    .PARAMETER Name

    An array of one or more service names to test against the specified permission set.

    .PARAMETER Permissions

    A manual set of permission to test again. One of:'QueryConfig', 'ChangeConfig', 'QueryStatus',
    'EnumerateDependents', 'Start', 'Stop', 'PauseContinue', 'Interrogate', UserDefinedControl',
    'Delete', 'ReadControl', 'WriteDac', 'WriteOwner', 'Synchronize', 'AccessSystemSecurity',
    'GenericAll', 'GenericExecute', 'GenericWrite', 'GenericRead', 'AllAccess'

    .PARAMETER PermissionSet

    A pre-defined permission set to test a specified service against. 'ChangeConfig', 'Restart', or 'AllAccess'.

    .OUTPUTS

    ServiceProcess.ServiceController

    .EXAMPLE

    PS C:\> Get-Service | Test-ServiceDaclPermission

    Return all service objects where the current user can modify the service configuration.

    .EXAMPLE

    PS C:\> Get-Service | Test-ServiceDaclPermission -PermissionSet 'Restart'

    Return all service objects that the current user can restart.


    .EXAMPLE

    PS C:\> Test-ServiceDaclPermission -Permissions 'Start' -Name 'VulnSVC'

    Return the VulnSVC object if the current user has start permissions.

    .LINK

    https://rohnspowershellblog.wordpress.com/2013/03/19/viewing-service-acls/
    #>
    [OutputType('ServiceProcess.ServiceController')]
    param (
        [Parameter(Position=0, Mandatory=$True, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$True)]
        [Alias('ServiceName')]
        [String[]]
        [ValidateNotNullOrEmpty()]
        $Name,

        [String[]]
        [ValidateSet('QueryConfig', 'ChangeConfig', 'QueryStatus', 'EnumerateDependents', 'Start', 'Stop', 'PauseContinue', 'Interrogate', 'UserDefinedControl', 'Delete', 'ReadControl', 'WriteDac', 'WriteOwner', 'Synchronize', 'AccessSystemSecurity', 'GenericAll', 'GenericExecute', 'GenericWrite', 'GenericRead', 'AllAccess')]
        $Permissions,

        [String]
        [ValidateSet('ChangeConfig', 'Restart', 'AllAccess')]
        $PermissionSet = 'ChangeConfig'
    )

    BEGIN {
        $AccessMask = @{
            'QueryConfig'           = [uint32]'0x00000001'
            'ChangeConfig'          = [uint32]'0x00000002'
            'QueryStatus'           = [uint32]'0x00000004'
            'EnumerateDependents'   = [uint32]'0x00000008'
            'Start'                 = [uint32]'0x00000010'
            'Stop'                  = [uint32]'0x00000020'
            'PauseContinue'         = [uint32]'0x00000040'
            'Interrogate'           = [uint32]'0x00000080'
            'UserDefinedControl'    = [uint32]'0x00000100'
            'Delete'                = [uint32]'0x00010000'
            'ReadControl'           = [uint32]'0x00020000'
            'WriteDac'              = [uint32]'0x00040000'
            'WriteOwner'            = [uint32]'0x00080000'
            'Synchronize'           = [uint32]'0x00100000'
            'AccessSystemSecurity'  = [uint32]'0x01000000'
            'GenericAll'            = [uint32]'0x10000000'
            'GenericExecute'        = [uint32]'0x20000000'
            'GenericWrite'          = [uint32]'0x40000000'
            'GenericRead'           = [uint32]'0x80000000'
            'AllAccess'             = [uint32]'0x000F01FF'
        }
        
        $CheckAllPermissionsInSet = $False

        if($PSBoundParameters['Permissions']) {
            $TargetPermissions = $Permissions
        }
        else {
            if($PermissionSet -eq 'ChangeConfig') {
                $TargetPermissions = @('ChangeConfig', 'WriteDac', 'WriteOwner', 'GenericAll', ' GenericWrite', 'AllAccess')
            }
            elseif($PermissionSet -eq 'Restart') {
                $TargetPermissions = @('Start', 'Stop')
                $CheckAllPermissionsInSet = $True # so we check all permissions && style
            }
            elseif($PermissionSet -eq 'AllAccess') {
                $TargetPermissions = @('GenericAll', 'AllAccess')
            }
        }
    }

    PROCESS {

        ForEach($IndividualService in $Name) {

            $TargetService = $IndividualService | Add-ServiceDacl

            # We might not be able to access the Service at all so we must check whether Add-ServiceDacl returned something.
            if ($TargetService -and $TargetService.Dacl) { 

                # Enumerate all group SIDs the current user is a part of
                $UserIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
                $CurrentUserSids = $UserIdentity.Groups | Select-Object -ExpandProperty Value
                $CurrentUserSids += $UserIdentity.User.Value

                # Check all the Dacl objects of the current service 
                ForEach($ServiceDacl in $TargetService.Dacl) {

                    $MatchingDaclFound = $False

                    # A Dacl object contains two properties we want to check: a SID and a list of AccessRights 
                    # First, we want to check if the current Dacl SID is in the list of SIDs of the current user 
                    if($CurrentUserSids -contains $ServiceDacl.SecurityIdentifier) {

                        if($CheckAllPermissionsInSet) {

                            # If a Permission Set was specified, we want to make sure that we have all the necessary access rights
                            $AllMatched = $True
                            ForEach($TargetPermission in $TargetPermissions) {
                                # check permissions && style
                                if (($ServiceDacl.AccessRights -band $AccessMask[$TargetPermission]) -ne $AccessMask[$TargetPermission]) {
                                    # Write-Verbose "Current user doesn't have '$TargetPermission' for $($TargetService.Name)"
                                    $AllMatched = $False
                                    break
                                }
                            }
                            if($AllMatched) {
                                $TargetService
                                $MatchingDaclFound = $True 
                            }
                        } else {

                            ForEach($TargetPermission in $TargetPermissions) {
                                # check permissions || style
                                if (($ServiceDacl.AceType -eq 'AccessAllowed') -and ($ServiceDacl.AccessRights -band $AccessMask[$TargetPermission]) -eq $AccessMask[$TargetPermission]) {
                                    Write-Verbose "Current user has '$TargetPermission' for $IndividualService"
                                    $TargetService
                                    $MatchingDaclFound = $True 
                                    break
                                }
                            }
                        }
                    }

                    if ($MatchingDaclFound) {
                        # As soon as we find a matching Dacl, we can stop searching 
                        break
                    }
                }
            } else {
                Write-Verbose "Error enumerating the Dacl for service $IndividualService"
            }
        }
    }
}

function Invoke-InstalledServicesCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>
    
    [CmdletBinding()] param()

    function Write-ArrayOfServices {
        [CmdletBinding()] param(
            [object[]]
            $Services
        )

        if (([object[]]$Services).Length -gt 0) {
            $User = $Services[0].User 
            if ($User -eq "LocalSystem") {
                Write-Message -Level Info "Found $(([object[]]$Services).Length) service(s) running as LocalSystem."
            } else {
                Write-Message -Level Info "Found $(([object[]]$Services).Length) other service(s)."
            }
            $global:IndentLevel += 1
            ForEach ($Service in $Services) {
                Write-Message -Level Info "Service: '$($Service.Name)' ($($Service.DisplayName)) - User: $($Service.User) - StartMode: $($Service.StartMode)"
            }
            $global:IndentLevel -= 1
        }
    }

    $InstalledServicesResult = New-Object -TypeName System.Collections.ArrayList

    # Get only third-party services 
    $FilteredServices = Get-ServiceList -FilterLevel 3

    Write-Message -Level Info "Found $(([object[]]$FilteredServices).Length) third-party service(s)."

    $ServicesRunningAsSystem = New-Object -TypeName System.Collections.ArrayList
    $ServicesRunningAsOther = New-Object -TypeName System.Collections.ArrayList
    ForEach ($Service in $FilteredServices) {
        $Properties = Get-ItemProperty -Path $Service.RegistryPath -ErrorAction SilentlyContinue -ErrorVariable GetItemPropertyError 
        if (-not $GetItemPropertyError) {
            $ServiceItem = New-Object -TypeName PSObject 
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Properties.PSChildName
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "DisplayName" -Value $Properties.DisplayName
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "User" -Value $Properties.ObjectName 
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "ImagePath" -Value $Properties.ImagePath 
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "StartMode" -Value $(Convert-ServiceStartModeToString -StartMode $Properties.Start)
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "Type" -Value $(Convert-ServiceTypeToString -ServiceType $Properties.Type)
            [void]$InstalledServicesResult.Add($ServiceItem)

            if ($Properties.ObjectName -eq "LocalSystem") {
                [void]$ServicesRunningAsSystem.Add($ServiceItem)
            } else {
                [void]$ServicesRunningAsOther.Add($ServiceItem)
            }
        }
    }

    Write-ArrayOfServices -Services $ServicesRunningAsSystem
    Write-ArrayOfServices -Services $ServicesRunningAsOther

    return $InstalledServicesResult
}

function Invoke-ServicesPermissionsRegistryCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>
    
    [CmdletBinding()] param()
    
    $ServicesPermissionsRegistryResult = New-Object -TypeName System.Collections.ArrayList 

    # Get all services except the ones with an empty ImagePath or Drivers 
    $AllServices = Get-ServiceList -FilterLevel 2 

    ForEach ($Service in $AllServices) {
        $ModifiablePath = Get-ModifiableRegistryPath -Path $Service.RegistryPath
        if ($ModifiablePath) {
            $ModifiableService = $Service 
            #$ModifiableService = New-Object -TypeName PSObject 
            #$ModifiableService | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Service.Name 
            $ModifiableService | Add-Member -MemberType "NoteProperty" -Name "ModifiablePath" -Value $Service.RegistryKey 
            $ModifiableService | Add-Member -MemberType "NoteProperty" -Name "IdentityReference" -Value $ModifiablePath.IdentityReference 
            $ModifiableService | Add-Member -MemberType "NoteProperty" -Name "Permissions" -Value $ModifiablePath.Permissions 

            $Status = "Unknown"
            # Can we restart the service?
            $ServiceRestart = Test-ServiceDaclPermission -Name $Service.Name -PermissionSet 'Restart'
            if ($ServiceRestart) { $UserCanRestart = $True; $Status = $ServiceRestart.Status } else { $UserCanRestart = $False }
    
            # Can we start the service?
            $ServiceStart = Test-ServiceDaclPermission -Name $Service.Name -Permissions 'Start'
            if ($ServiceStart) { $UserCanStart = $True; $Status = $ServiceRestart.Status } else { $UserCanStart = $False }
    
            $ModifiableService | Add-Member -MemberType "NoteProperty" -Name "Status" -Value $Status
            $ModifiableService | Add-Member -MemberType "NoteProperty" -Name "UserCanStart" -Value $UserCanStart
            $ModifiableService | Add-Member -MemberType "NoteProperty" -Name "UserCanRestart" -Value $UserCanRestart

            [void]$ServicesPermissionsRegistryResult.Add([object]$ModifiableService) 
        }
    }

    if (([object[]]$ServicesPermissionsRegistryResult).Length -gt 0) {
        Write-Message -Level Success "Found $(([object[]]$ServicesPermissionsRegistryResult).Length) modifiable registry key(s)."
        $global:IndentLevel += 1
        ForEach ($Result in $ServicesPermissionsRegistryResult) {
            Write-ServiceStatus -Service $Result
            $global:IndentLevel += 1
            Write-Message -Level Success "Modifiable path:    $($Result.ModifiablePath)"
            Write-Message -Level Info "Identity Reference: $($Result.IdentityReference)"
            Write-Message -Level Info "Permissions:        $($Result.Permissions)" 
            $global:IndentLevel -= 1
        }
        $global:IndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any modifiable registry key."
    }

    return $ServicesPermissionsRegistryResult
}

function Invoke-ServicesUnquotedPathCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>
    
    [CmdletBinding()] param()

    $ServicesUnquotedPathResult = New-Object -TypeName System.Collections.ArrayList 

    # Get all services which have a non-empty ImagePath
    $Services = Get-ServiceList -FilterLevel 1
    
    $PermissionsAddFile = @("WriteData/AddFile", "DeleteChild", "WriteDAC", "WriteOwner")
    $PermissionsAddFolder = @("AppendData/AddSubdirectory", "DeleteChild", "WriteDAC", "WriteOwner")

    ForEach ($Service in $Services) {
        $ImagePath = $Service.ImagePath.trim()

        # If the ImagePath doesn't start with a " or a ' 
        if (-not ($ImagePath.StartsWith("`"") -or $ImagePath.StartsWith("'"))) {
            
            # Extract the binpath from the ImagePath
            $BinPath = $ImagePath.SubString(0, $ImagePath.ToLower().IndexOf(".exe") + 4)

            # If the binpath contains spaces 
            If ($BinPath -match ".* .*") {
                $ModifiableFiles = $BinPath.split(' ') | Get-ModifiablePath

                $VulnPaths = @() 

                $ModifiableFiles | Where-Object {$_ -and $_.ModifiablePath -and ($_.ModifiablePath -ne '')} | Foreach-Object {
                     
                    $TempPath = $([System.Environment]::ExpandEnvironmentVariables($BinPath))
                    $TempPath = Split-Path -Path $TempPath -Parent 
                    while ($TempPath) 
                    {
                        try {
                            $ParentPath = Split-Path -Path $TempPath -Parent 
                            if ($ParentPath -eq $_.ModifiablePath) {
                                $PermissionsSet = $Null 
                                if (Test-Path -Path $TempPath -ErrorAction SilentlyContinue) {
                                    # If the current folder exists, can we create files in it?
                                    #"Folder $($TempPath) exists, can we create files in $($ParentPath)???"
                                    $PermissionsSet = $PermissionsAddFile
                                } else {
                                    # The current folder doesn't exist, can we create it? 
                                    #"Folder $($TempPath) doesn't exist, can we create the folder $($ParentPath)???"
                                    $PermissionsSet = $PermissionsAddFolder 
                                }
                                ForEach ($Permission in $_.Permissions) {
                                    if ($PermissionsSet -contains $Permission) {
                                        $VulnPaths += $_
                                        break
                                    }
                                }
                                # We found the path returned by Get-ModifiablePath so we can exit the while loop 
                                break
                            }
                        } catch {
                            # because Split-Path doesn't handle -ErrorAction SilentlyContinue nicely
                            # exit safely to avoid an infinite loop 
                            break 
                        }
                        $TempPath = $ParentPath
                    }
                }

                if ($VulnPaths) {
                    $VulnService = $Service 
                    $VulnService | Add-Member -MemberType "NoteProperty" -Name "VulnPaths" -Value $VulnPaths

                    $Status = "Unknown"
                    # Can we restart the service?
                    $ServiceRestart = Test-ServiceDaclPermission -Name $Service.Name -PermissionSet 'Restart'
                    if ($ServiceRestart) { $UserCanRestart = $True; $Status = $ServiceRestart.Status } else { $UserCanRestart = $False }
            
                    # Can we start the service?
                    $ServiceStart = Test-ServiceDaclPermission -Name $Service.Name -Permissions 'Start'
                    if ($ServiceStart) { $UserCanStart = $True; $Status = $ServiceRestart.Status } else { $UserCanStart = $False }
            
                    $VulnService | Add-Member -MemberType "NoteProperty" -Name "Status" -Value $Status
                    $VulnService | Add-Member -MemberType "NoteProperty" -Name "UserCanStart" -Value $UserCanStart
                    $VulnService | Add-Member -MemberType "NoteProperty" -Name "UserCanRestart" -Value $UserCanRestart

                    [void]$ServicesUnquotedPathResult.Add([object]$VulnService) 
                }
            }
        }
    }

    if (([object[]]$ServicesUnquotedPathResult).Length -gt 0) {

        Write-Message -Level Success "Found $(([object[]]$ServicesUnquotedPathResult).Length) vulnerable service(s)."

        $global:IndentLevel += 1
        ForEach ($Result in $ServicesUnquotedPathResult) {
            Write-ServiceStatus -Service $Result
            $global:IndentLevel += 1
            ForEach ($Path in $Result.VulnPaths) {     
                Write-Message -Level Success "Modifiable path: $($Path.ModifiablePath)"
                Write-Message -Level Info "Identity Reference: $($Path.IdentityReference)"
                Write-Message -Level Info "Permissions:        $($Path.Permissions)"
            }
            $global:IndentLevel -= 1
        }
        $global:IndentLevel -= 1

    } else {
        Write-Message -Level Warning "Didn't find any vulnerable service."
    }

    return $ServicesUnquotedPathResult
}

function Invoke-ServicesImagePermissionsCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>
    
    [CmdletBinding()] param()
    
    $ServicesImagePermissionsResult = New-Object -TypeName System.Collections.ArrayList 

    $Services = Get-ServiceList -FilterLevel 1

    ForEach ($Service in $Services) {

        $ModifiablePaths = $Service.ImagePath | Get-ModifiablePath

        if ($ModifiablePaths) {
            $VulnService = $Service
            $VulnService | Add-Member -MemberType "NoteProperty" -Name "VulnPaths" -Value $ModifiablePaths

            $Status = "Unknown"
            # Can we restart the service?
            $ServiceRestart = Test-ServiceDaclPermission -Name $Service.Name -PermissionSet 'Restart'
            if ($ServiceRestart) { $UserCanRestart = $True; $Status = $ServiceRestart.Status } else { $UserCanRestart = $False }
    
            # Can we start the service?
            $ServiceStart = Test-ServiceDaclPermission -Name $Service.Name -Permissions 'Start'
            if ($ServiceStart) { $UserCanStart = $True; $Status = $ServiceRestart.Status } else { $UserCanStart = $False }
    
            $VulnService | Add-Member -MemberType "NoteProperty" -Name "Status" -Value $Status
            $VulnService | Add-Member -MemberType "NoteProperty" -Name "UserCanStart" -Value $UserCanStart
            $VulnService | Add-Member -MemberType "NoteProperty" -Name "UserCanRestart" -Value $UserCanRestart

            [void]$ServicesImagePermissionsResult.Add([object]$VulnService) 
        }
    }

    if (([object[]]$ServicesImagePermissionsResult).Length -gt 0) {
        Write-Message -Level Success "Found $(([object[]]$ServicesImagePermissionsResult).Length) potentially vulnerable service(s)."
        $global:IndentLevel += 1
        ForEach ($Result in $ServicesImagePermissionsResult) {
            Write-ServiceStatus -Service $Result
            $global:IndentLevel += 1
            ForEach ($Path in $Result.VulnPaths) {
                Write-Message -Level Success "Modifiable path:    $($Path.ModifiablePath)"
                Write-Message -Level Info "Identity Reference: $($Path.IdentityReference)"
                Write-Message -Level Info "Permissions:        $($Path.Permissions)"
            }
            $global:IndentLevel -= 1
        }
        $global:IndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any vulnerable service."
    }

    return $ServicesImagePermissionsResult
}

function Invoke-ServicesPermissionsCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>
    

    # Base on PowerUp.ps1 - Test-ServiceDaclPermission 
    # https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1
    
    [CmdletBinding()] param()

    $ServicesPermissionsResult = New-Object -TypeName System.Collections.ArrayList

    # Get-ServiceList returns a list of custom Service objects 
    # The properties of a custom Service object are: Name, DisplayName, User, ImagePath, StartMode, Type, RegsitryKey, RegistryPath 
    # We also apply the FilterLevel 1 to filter out services which have an empty ImagePath 
    $Services = Get-ServiceList -FilterLevel 1

    # For each custom Service object in the list 
    ForEach ($Service in $Services) {

        # Get a 'real' Service object and the associated DACL, based on its name 
        $TargetService = Test-ServiceDaclPermission -Name $Service.Name -PermissionSet 'ChangeConfig'

        if ($TargetService) {

            $ServiceRestart = Test-ServiceDaclPermission -Name $Service.Name -PermissionSet 'Restart'
            if ($ServiceRestart) { $UserCanRestart = $True } else { $UserCanRestart = $False }

            $ServiceStart = Test-ServiceDaclPermission -Name $Service.Name -Permissions 'Start'
            if ($ServiceStart) { $UserCanStart = $True } else { $UserCanStart = $False }

            $ServicesPermissionsItem = $Service
            $ServicesPermissionsItem | Add-Member -MemberType "NoteProperty" -Name "Status" -Value $TargetService.Status 
            $ServicesPermissionsItem | Add-Member -MemberType "NoteProperty" -Name "UserCanStart" -Value $UserCanStart
            $ServicesPermissionsItem | Add-Member -MemberType "NoteProperty" -Name "UserCanRestart" -Value $UserCanRestart
            [void]$ServicesPermissionsResult.Add($ServicesPermissionsItem)
        }
    }

    if (([object[]]$ServicesPermissionsResult).Length -gt 0) {
        Write-Message -Level Success "Found $(([object[]]$ServicesPermissionsResult).Length) potentially vulnerable services."
        $global:IndentLevel += 1
        ForEach ($Result in $ServicesPermissionsResult) {
            Write-ServiceStatus -Service $Result
        }
        $global:IndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any vulnerable service."
    }
    
    return $ServicesPermissionsResult
}
# ----------------------------------------------------------------
# END SERVICES   
# ----------------------------------------------------------------

# ----------------------------------------------------------------
# END DLL HIJACKING   
# ----------------------------------------------------------------
function Invoke-DllHijackingCheck {
    <#
    .SYNOPSIS
    TODO: Short description
    
    .DESCRIPTION
    TODO: Long description
    
    .EXAMPLE
    TODO: An example
    
    .NOTES
    TODO: General notes
    #>
    
    [CmdletBinding()] param()
    
    $DllHijackingResult = New-Object -TypeName System.Collections.ArrayList

    $SystemPath = (Get-ItemProperty -Path "Registry::HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" -Name "Path").Path 
    $Paths = $SystemPath.Split(';')

    ForEach ($Path in $Paths) {
        if ($Path -and $Path -ne '') {
            $ModifiablePaths = $Path | Get-ModifiablePath -LiteralPaths 
            ForEach ($ModifiablePath in $ModifiablePaths) {
                if ($Null -ne $ModifiablePath.ModifiablePath) {
                    [void]$DllHijackingResult.Add([object]$ModifiablePath) 
                }
            }
        }
    }

    if (([object[]]$DllHijackingResult).Length -gt 0) {
        Write-Message -Level Success "Found $(([object[]]$DllHijackingResult).Length) vulnerable path(s)."
        $global:IndentLevel += 1
        ForEach ($Result in $DllHijackingResult) {
            Write-Message -Level Success "Path: $($Result.ModifiablePath)"
            $global:IndentLevel += 1
            Write-Message -Level Info "Identity Reference: $($Result.IdentityReference)"
            Write-Message -Level Info "Permissions:        $($Result.Permissions)"
            $global:IndentLevel -= 1
        }
        $global:IndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any vulnerable path."
    }

    return $DllHijackingResult
}
# ----------------------------------------------------------------
# END DLL HIJACKING   
# ----------------------------------------------------------------
#endregion Checks

# ----------------------------------------------------------------
# Main  
# ----------------------------------------------------------------
#region Main
function Invoke-PrivescCheck {

    [CmdletBinding()] param(
        [switch]
        $DirectOutput = $False
    )

    if ($DirectOutput) {
        $global:DirectOutput = $True 
    }

    $Results = $Null ; $Results | Out-Null 

    "----------------------------------------------------------------"
    "|                          PRIVILEGES                          |"
    "----------------------------------------------------------------"

    "TEST: Checking user privileges"
    "DESC: Do we have any interesting privilege? e.g.: SeImpersonate, SeAssignPrimaryToken"
    $Results = Invoke-UserPrivilegesCheck
    #$Results | Format-List 

    Write-Host "`n"

    "----------------------------------------------------------------"
    "|                           SERVICES                           |"
    "----------------------------------------------------------------"

    "TEST: Listing third-party services"
    "DESC: Buil-in services are (usually) properly configured, what about third-party software?"
    $Results = Invoke-InstalledServicesCheck
    #$Results | Format-List

    Write-Host "`n"

    "TEST: Checking service permissions (registry)"
    "DESC: Can we change the configuration of any service in the registry?"
    $Results = Invoke-ServicesPermissionsRegistryCheck
    #$Results | Format-List

    Write-Host "`n"

    "TEST: Checking services permissions"
    "DESC: Can we change the configuration of any service through the Service Manager?"
    $Results = Invoke-ServicesPermissionsCheck
    #$Results | Format-List

    Write-Host "`n"
    
    "TEST: Checking for unquoted service paths"
    "DESC: If a service is confgured with an unquoted path, we may potentially plant a binary in a parent folder."
    $Results = Invoke-ServicesUnquotedPathCheck
    #$Results | Format-List

    Write-Host "`n"

    "TEST: Checking service executable and argument permissions"
    "DESC: If we can somehow control the executable itself or one of its parameters, we could potentially hijack the service."
    $Results = Invoke-ServicesImagePermissionsCheck
    #$Results | Format-List

    Write-Host "`n"

    "----------------------------------------------------------------"
    "|                         DLL HIJACKING                        |"
    "----------------------------------------------------------------"

    "TEST: Checking system %PATH% for potentially hijackable DLL locations"
    "DESC: If we have write permissions in a %PATH% folder, we could potentially load a malicious DLL."
    $Results = Invoke-DllHijackingCheck
    #$Results | Format-List

    Write-Host "`n"

    "----------------------------------------------------------------"
    "|                        SENSITIVE FILES                       |"
    "----------------------------------------------------------------"

    "TEST: Checking SAM/SYSTEM files"
    "DESC: Is there any backup of the SAM/SYSTEM hives we can read?"
    $Results = Invoke-SamBackupFilesCheck
    #$Results | Format-List 

    Write-Host "`n"

    "----------------------------------------------------------------"
    "|                       INSTALLED PROGRAMS                     |"
    "----------------------------------------------------------------"
    "TEST: Listing third-party programs"
    "DESC: Default application folders have proper permissions but what about third-party software?"
    $Results = Invoke-InstalledProgramsCheck
    #$Results | Format-List 

    Write-Host "`n"
    
    "TEST: Checking modifiable programs"
    "DESC: Can we replace an existing executable with a malicious one? Or DLL planting/proxying?"
    $Results = Invoke-ModifiableProgramsCheck
    #$Results | Format-List

    Write-Host "`n"

    "----------------------------------------------------------------"
    "|                          CREDENTIALS                         |"
    "----------------------------------------------------------------"

    "TEST: Checking WinLogon registry key"
    "DESC: A password is potentially stored there (you never know ^^)."
    $Results = Invoke-WinlogonCheck
    #$Results | Format-List 

    Write-Host "`n"

    "TEST: Checking Credential files"
    "DESC: Credentials can be found in the current user's home folder."
    $Results = Invoke-CredentialFilesCheck
    #$Results | Format-List

    Write-Host "`n"

    "----------------------------------------------------------------"
    "|                       REGISTRY SETTINGS                      |"
    "----------------------------------------------------------------"

    "TEST: Checking UAC settings"
    "DESC: Is UAC enabled?"
    $Results = Invoke-UacCheck
    #$Results | Format-List 
    
    Write-Host "`n"

    "TEST: Checking LAPS settings"
    "DESC: Is LAPS enabled?"
    $Results = Invoke-LapsCheck
    #$Results | Format-List 
    
    Write-Host "`n"

    "TEST: Checking PowerShell Transcription settings"
    "DESC: PowerShell script execution events might be logged to a local folder."
    $Results = Invoke-PowershellTranscriptionCheck
    #$Results | Format-List 
    
    Write-Host "`n"

    "TEST: Checking for AlwaysInstallElevated registry key"
    "DESC: If enabled, we can run an MSI file as SYSTEM."
    $Results = Invoke-RegistryAlwaysInstallElevatedCheck
    #$Results | Format-List 
    
    Write-Host "`n"

    "----------------------------------------------------------------"
    "|                             MISC                             |"
    "----------------------------------------------------------------"

    "TEST: Checking system version"
    "DESC: Is the system up to date?"
    $Results = Invoke-SystemInfoCheck
    #$Results | Format-List 

    Write-Host "`n"

    "TEST: Checking machine role (Workstation, server, DC)"
    "DESC: We want to know what we are dealing with."
    $Results = Invoke-MachineRoleCheck 
    #$Results | Format-List 

    Write-Host "`n"

    "TEST: Checking last Windows Update installation date"
    "DESC: If the machine isn't updated on a regular basis, we might be able to use public exploits."
    $Results = Invoke-WindowsUpdateCheck 
    #$Results | Format-List 

    Write-Host "`n"

    "TEST: Checking local admin group"
    "DESC: Which user could we target next?"
    $Results = Invoke-LocalAdminGroupCheck
    #$Results | Format-List 
    
    Write-Host "`n"

    "TEST: Checking system startup history"
    "DESC: Some exploits may require a reboot (e.g.: DLL Hijacking) so this information can be useful."
    $Results = Invoke-SystemStartupHistoryCheck
    #$Results | Format-List 

    Write-Host "`n"

    "TEST: Checking file system drives"
    "DESC: It's quite common to see program folders configured with weak permissions on additional partitions."
    $Results = Invoke-SystemDrivesCheck
    #$Results | Format-List 

    Write-Host "`n"

}
#endregion Main
