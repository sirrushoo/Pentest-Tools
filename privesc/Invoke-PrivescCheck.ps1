<#

https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/
https://book.hacktricks.xyz/windows/windows-local-privilege-escalation
#>

#Requires -Version 3

# ----------------------------------------------------------------
# Helpers 
# ----------------------------------------------------------------
#region Helpers 
$GlobalIndentLevel = 0

$GlobalIgnoredPrograms = @("Common Files", "Internet Explorer", "ModifiableWindowsApps", "VMware", "Windows Defender", "Windows Defender Advanced Threat Protection", "Windows Mail", "Windows Media Player", "Windows Multimedia Platform", "Windows NT", "Windows Photo Viewer", "Windows Portable Devices", "Windows Security", "WindowsPowerShell", "Microsoft.NET", "Windows Portable Devices", "dotnet", "MSBuild", "Intel", "Reference Assemblies")

$GlobalIgnoredServices = @("1394ohci", "3ware", "AarSvc", "ACPI", "AcpiDev", "acpiex", "acpipagr", "AcpiPmi", "acpitime", "Acx01000", "ADOVMPPackage", "ADP80XX", "adsi", "AFD", "afunix", "ahcache", "AJRouter", "ALG", "amdgpio2", "amdi2c", "AmdK8", "AmdPPM", "amdsata", "amdsbs", "amdxata", "AppID", "AppIDSvc", "Appinfo", "applockerfltr", "AppMgmt", "AppReadiness", "AppVClient", "AppvStrm", "AppvVemgr", "AppvVfs", "AppXSvc", "arcsas", "AssignedAccessManagerSvc", "AsyncMac", "atapi", "AudioEndpointBuilder", "Audiosrv", "autotimesvc", "AxInstSV", "b06bdrv", "bam", "BasicDisplay", "BasicRender", "BattC", "BcastDVRUserService", "bcmfn2", "BDESVC", "Beep", "BFE", "bindflt", "BITS", "BluetoothUserService", "bowser", "BrokerInfrastructure", "Browser", "BTAGService", "BthA2dp", "BthAvctpSvc", "BthEnum", "BthHFEnum", "BthLEEnum", "BthMini", "BTHMODEM", "BthPan", "BTHPORT", "bthserv", "BTHUSB", "bttflt", "buttonconverter", "CAD", "camsvc", "CaptureService", "cbdhsvc", "cdfs", "CDPSvc", "CDPUserSvc", "cdrom", "CertPropSvc", "cht4iscsi", "cht4vbd", "CimFS", "circlass", "CldFlt", "CLFS", "ClipSVC", "CmBatt", "CNG", "cnghwassist", "CompositeBus", "COMSysApp", "condrv", "ConsentUxUserSvc", "CoreMessagingRegistrar", "CoreUI", "CredentialEnrollmentManagerUserSvc", "crypt32", "CryptSvc", "CSC", "CscService", "dam", "DCLocator", "DcomLaunch", "defragsvc", "DeviceAssociationBrokerSvc", "DeviceAssociationService", "DeviceInstall", "DevicePickerUserSvc", "DevicesFlowUserSvc", "DevQueryBroker", "Dfsc", "Dhcp", "diagnosticshub.standardcollector.service", "diagsvc", "DiagTrack", "disk", "DispBrokerDesktopSvc", "DisplayEnhancementService", "DmEnrollmentSvc", "dmvsc", "dmwappushservice", "Dnscache", "DoSvc", "dot3svc", "DPS", "drmkaud", "DsmSvc", "DsSvc", "DusmSvc", "DXGKrnl", "e1i65x64", "Eaphost", "ebdrv", "EFS", "EhStorClass", "EhStorTcgDrv", "embeddedmode", "EntAppSvc", "ErrDev", "ESENT", "EventLog", "EventSystem", "exfat", "fastfat", "Fax", "fdc", "fdPHost", "FDResPub", "fhsvc", "FileCrypt", "FileInfo", "Filetrace", "flpydisk", "FltMgr", "FontCache", "FrameServer", "FsDepends", "Fs_Rec", "fvevol", "gencounter", "genericusbfn", "GPIOClx0101", "gpsvc", "GpuEnergyDrv", "GraphicsPerfSvc", "HdAudAddService", "HDAudBus", "HidBatt", "HidBth", "hidi2c", "hidinterrupt", "HidIr", "hidserv", "hidspi", "HidUsb", "HomeGroupListener", "HomeGroupProvider", "HpSAMD", "HTTP", "hvcrash", "HvHost", "hvservice", "HwNClx0101", "hwpolicy", "hyperkbd", "HyperVideo", "i8042prt", "iagpio", "iai2c", "iaLPSS2i_GPIO2", "iaLPSS2i_GPIO2_BXT_P", "iaLPSS2i_GPIO2_CNL", "iaLPSS2i_GPIO2_GLK", "iaLPSS2i_I2C", "iaLPSS2i_I2C_BXT_P", "iaLPSS2i_I2C_CNL", "iaLPSS2i_I2C_GLK", "iaLPSSi_GPIO", "iaLPSSi_I2C", "iaStorAV", "iaStorAVC", "iaStorV", "ibbus", "icssvc", "IKEEXT", "IndirectKmd", "inetaccs", "InstallService", "intelide", "intelpep", "intelpmax", "intelppm", "iorate", "IpFilterDriver", "iphlpsvc", "IPMIDRV", "IPNAT", "IPT", "IpxlatCfgSvc", "isapnp", "iScsiPrt", "ItSas35i", "kbdclass", "kbdhid", "kdnic", "KeyIso", "KSecDD", "KSecPkg", "ksthunk", "KtmRm", "LanmanServer", "LanmanWorkstation", "ldap", "lfsvc", "LicenseManager", "lltdio", "lltdsvc", "lmhosts", "Lsa", "LSI_SAS", "LSI_SAS2i", "LSI_SAS3i", "LSI_SSS", "LSM", "luafv", "LxpSvc", "MapsBroker", "mausbhost", "mausbip", "MbbCx", "megasas", "megasas2i", "megasas35i", "megasr", "MessagingService", "Microsoft_Bluetooth_AvrcpTransport", "MixedRealityOpenXRSvc", "mlx4_bus", "MMCSS", "Modem", "monitor", "mouclass", "mouhid", "mountmgr", "mpsdrv", "mpssvc", "MRxDAV", "mrxsmb", "mrxsmb20", "MsBridge", "Msfs", "msgpiowin32", "mshidkmdf", "mshidumdf", "msisadrv", "MSiSCSI", "msiserver", "MSKSSRV", "MsLldp", "MSPCLOCK", "MSPQM", "MsQuic", "MsRPC", "MSSCNTRS", "MsSecFlt", "mssmbios", "MSTEE", "MTConfig", "Mup", "mvumis", "napagent", "NativeWifiP", "NaturalAuthentication", "NcaSvc", "NcbService", "NcdAutoSetup", "ndfltr", "NDIS", "NdisCap", "NdisImPlatform", "NdisTapi", "Ndisuio", "NdisVirtualBus", "NdisWan", "ndiswanlegacy", "NDKPing", "ndproxy", "Ndu", "NetAdapterCx", "NetBIOS", "NetbiosSmb", "NetBT", "Netlogon", "Netman", "netprofm", "NetSetupSvc", "NetTcpPortSharing", "netvsc", "NgcCtnrSvc", "NgcSvc", "NlaSvc", "Npfs", "npsvctrig", "nsi", "nsiproxy", "NTDS", "Ntfs", "Null", "nvdimm", "nvraid", "nvstor", "OneSyncSvc", "p2pimsvc", "p2psvc", "Parport", "partmgr", "PcaSvc", "pci", "pciide", "pcmcia", "pcw", "pdc", "PEAUTH", "PeerDistSvc", "perceptionsimulation", "percsas2i", "percsas3i", "PerfDisk", "PerfHost", "PerfNet", "PerfOS", "PerfProc", "PhoneSvc", "PimIndexMaintenanceSvc", "PktMon", "pla", "PlugPlay", "pmem", "PNPMEM", "PNRPAutoReg", "PNRPsvc", "PolicyAgent", "portcfg", "PortProxy", "Power", "PptpMiniport", "PrintNotify", "PrintWorkflowUserSvc", "Processor", "ProfSvc", "Psched", "PushToInstall", "pvscsi", "QWAVE", "QWAVEdrv", "Ramdisk", "RasAcd", "RasAgileVpn", "RasAuto", "Rasl2tp", "RasMan", "RasPppoe", "RasSstp", "rdbss", "RDMANDK", "rdpbus", "RDPDR", "RDPNP", "RDPUDD", "RdpVideoMiniport", "rdyboost", "ReFS", "ReFSv1", "RemoteAccess", "RemoteRegistry", "RetailDemo", "RFCOMM", "rhproxy", "RmSvc", "RpcEptMapper", "RpcLocator", "RpcSs", "rspndr", "s3cap", "SamSs", "sbp2port", "SCardSvr", "ScDeviceEnum", "scfilter", "Schedule", "scmbus", "SCPolicySvc", "sdbus", "SDFRd", "SDRSVC", "sdstor", "seclogon", "SecurityHealthService", "SEMgrSvc", "SENS", "Sense", "SensorDataService", "SensorService", "SensrSvc", "SerCx", "SerCx2", "Serenum", "Serial", "sermouse", "SessionEnv", "sfloppy", "SgrmAgent", "SgrmBroker", "SharedAccess", "SharedRealitySvc", "ShellHWDetection", "shpamsvc", "SiSRaid2", "SiSRaid4", "SmartSAMD", "smbdirect", "smphost", "SmsRouter", "SMSvcHost 4.0.0.0", "SNMPTRAP", "spaceparser", "spaceport", "SpatialGraphFilter", "SpbCx", "spectrum", "Spooler", "sppsvc", "srv2", "srvnet", "SSDPSRV", "ssh-agent", "SstpSvc", "StateRepository", "stexstor", "stisvc", "storahci", "storflt", "stornvme", "storqosflt", "StorSvc", "storufs", "storvsc", "svsvc", "swenum", "swprv", "Synth3dVsc", "SysMain", "SystemEventsBroker", "TabletInputService", "TapiSrv", "Tcpip", "Tcpip6", "TCPIP6TUNNEL", "tcpipreg", "TCPIPTUNNEL", "tdx", "Telemetry", "terminpt", "TermService", "Themes", "TieringEngineService", "TimeBrokerSvc", "TokenBroker", "TPM", "TrkWks", "TroubleshootingSvc", "TrustedInstaller", "TSDDD", "TsUsbFlt", "TsUsbGD", "tsusbhub", "tunnel", "tzautoupdate", "UASPStor", "UcmCx0101", "UcmTcpciCx0101", "UcmUcsiAcpiClient", "UcmUcsiCx0101", "Ucx01000", "UdeCx", "udfs", "UdkUserSvc", "UEFI", "UevAgentDriver", "UevAgentService", "Ufx01000", "UfxChipidea", "ufxsynopsys", "UGatherer", "UGTHRSVC", "umbus", "UmPass", "UmRdpService", "UnistoreSvc", "upnphost", "UrsChipidea", "UrsCx01000", "UrsSynopsys", "usbaudio", "usbaudio2", "usbccgp", "usbcir", "usbehci", "usbhub", "USBHUB3", "usbohci", "usbprint", "usbser", "USBSTOR", "usbuhci", "USBXHCI", "UserDataSvc", "UserManager", "UsoSvc", "VacSvc", "VaultSvc", "vdrvroot", "vds", "VerifierExt", "VGAuthService", "vhdmp", "vhf", "Vid", "VirtualRender", "vm3dmp", "vm3dmp-debug", "vm3dmp-stats", "vm3dmp_loader", "vmbus", "VMBusHID", "vmci", "vmgid", "vmhgfs", "vmicguestinterface", "vmicheartbeat", "vmickvpexchange", "vmicrdv", "vmicshutdown", "vmictimesync", "vmicvmsession", "vmicvss", "VMMemCtl", "vmmouse", "vmrawdsk", "vmusbmouse", "vmvss", "vmwefifw", "vmxnet3ndis6", "volmgr", "volmgrx", "volsnap", "volume", "vpci", "vsmraid", "vsock", "VSS", "VSTXRAID", "vwifibus", "vwififlt", "W32Time", "WaaSMedicSvc", "WacomPen", "WalletService", "wanarp", "wanarpv6", "WarpJITSvc", "wbengine", "WbioSrvc", "wcifs", "Wcmsvc", "wcncsvc", "wcnfs", "WdBoot", "Wdf01000", "WdFilter", "WdiServiceHost", "WdiSystemHost", "wdiwifi", "WdmCompanionFilter", "WdNisDrv", "WdNisSvc", "WebClient", "Wecsvc", "WEPHOSTSVC", "wercplsupport", "WerSvc", "WFDSConMgrSvc", "WFPLWFS", "WiaRpc", "WIMMount", "WinDefend", "Windows Workflow Foundation 4.0.0.0", "WindowsTrustedRT", "WindowsTrustedRTProxy", "WinHttpAutoProxySvc", "WinMad", "Winmgmt", "WinNat", "WinRM", "Winsock", "WinSock2", "WINUSB", "WinVerbs", "wisvc", "WlanSvc", "wlidsvc", "wlpasvc", "WManSvc", "WmiAcpi", "WmiApRpl", "wmiApSrv", "WMPNetworkSvc", "Wof", "workerdd", "workfolderssvc", "WpcMonSvc", "WPDBusEnum", "WpdUpFltr", "WpnService", "WpnUserService", "ws2ifsl", "wscsvc", "WSearch", "WSearchIdxPi", "wuauserv", "WudfPf", "WUDFRd", "WwanSvc", "XblAuthManager", "XblGameSave", "xboxgip", "XboxGipSvc", "XboxNetApiSvc", "xinputhid", "xmlprov")

function Write-Message {
    [CmdletBinding()] param(
        [String]
        $Message,
        [ValidateSet("Success", "Info", "Warning", "Error")][String]
        $Level
    )

    For ($i = 0; $i -lt $GlobalIndentLevel; $i++) {
        Write-Host -NoNewLine "    "
    }

    if ($Level -eq "Success") {
        Write-Host -ForegroundColor Green -NoNewline "[+] "
    } elseif ($Level -eq "Info") {
        Write-Host -ForegroundColor Blue -NoNewline "[*] "
    } elseif ($Level -eq "Warning") {
        Write-Host -ForegroundColor Yellow -NoNewline "[!] "
    } elseif ($Level -eq "Error") {
        Write-Host -ForegroundColor Red -NoNewline "[-] "
    } 

    Write-Host $Message
}

function Convert-DateToString {
    [CmdletBinding()] param(
        [System.DateTime]
        $Date
    )

    return $Date.ToString('yyyy-MM-dd - HH:mm:ss')
}

function Convert-ServiceTypeToString {
    [CmdletBinding()] param(
        [int]
        $ServiceType
    )

    $Result = ""

    if ($ServiceType -eq 1) {
        $Result = "KernelDriver"
    } elseif ($ServiceType -eq 2) {
        $Result = "FileSystemDriver"
    } elseif ($ServiceType -eq 4) {
        $Result = "Adapter"
    } elseif ($ServiceType -eq 8) {
        $Result = "RecognizerDriver"
    } elseif ($ServiceType -eq 16) {
        $Result = "Win32OwnProcess"
    } elseif ($ServiceType -eq 32) {
        $Result = "Win32ShareProcess"
    } elseif ($ServiceType -eq 256) {
        $Result = "InteractiveProcess"
    } else {
        $Result = "Unknown"
    }

    return $Result
}

function Convert-ServiceStartModeToString {
    [CmdletBinding()] param(
        [int]
        $StartMode
    )

    $Result = ""

    if ($StartMode -eq 0) {
        $Result = "Boot"
    } elseif ($StartMode -eq 1) {
        $Result = "System"
    } elseif ($StartMode -eq 2) {
        $Result = "Automatic"
    } elseif ($StartMode -eq 3) {
        $Result = "Manual"
    } elseif ($StartMode -eq 4) {
        $Result = "Disabled"
    } else {
        $Result = "Unknown"
    }

    return $Result
}

function Test-IsKnownService {
    [CmdletBinding()] param(
        [string]
        $ServiceName
    )

    $KnownServices = @("AarSvc_*", "BcastDVRUserService_*", "BluetoothUserService_*", "CaptureService_*", "cbdhsvc_*", "CDPUserSvc_*", "clr_optimization_*", "ConsentUxUserSvc_*", "CredentialEnrollmentManagerUserSvc_*", "DeviceAssociationBrokerSvc_*", "DevicePickerUserSvc_*", "DevicesFlowUserSvc_*", "FontCache*", "IpOverUsbSvc", "MessagingService_*", "MSDTC*", ".NET*", "OneSyncSvc_*", "PimIndexMaintenanceSvc_*", "PrintWorkflowUserSvc_*", "UdkUserSvc_*", "UnistoreSvc_*", "UserDataSvc_*", "WpnUserService_*")

    if ($GlobalIgnoredServices -contains $ServiceName) {
        return $True 
    } else {
        ForEach ($KnownService in $KnownServices) {
            if ($ServiceName -like $KnownService) {
                return $True 
            }
        }
    }
    return $False 
}

function Get-InstalledPrograms {
    [CmdletBinding()] param(
        [switch]
        $Filtered = $False
    )

    $InstalledProgramsResult = New-Object System.Collections.ArrayList

    $InstalledPrograms = New-Object System.Collections.ArrayList

    $PathProgram32 = Join-Path -Path $env:SystemDrive -ChildPath "Program Files (x86)"
    $PathProgram64 = Join-Path -Path $env:SystemDrive -ChildPath "Program Files" 

    [void]$InstalledPrograms.AddRange($(Get-ChildItem -Path $PathProgram32,$PathProgram64 -ErrorAction SilentlyContinue))
    
    $RegInstalledPrograms = Get-ChildItem -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"
    ForEach ($InstalledProgram in $RegInstalledPrograms) {
        $InstallLocation = [System.Environment]::ExpandEnvironmentVariables($InstalledProgram.GetValue("InstallLocation"))
        if ($InstallLocation) {
            if (Test-Path -Path $InstallLocation) {
                if ($InstallLocation[$InstallLocation.Length - 1] -eq "\") {
                    $InstallLocation = $InstallLocation.SubString(0, $InstallLocation.Length - 1)
                }
                $FileObject = Get-Item -Path $InstallLocation -ErrorAction SilentlyContinue -ErrorVariable GetItemError 
                if ($GetItemError) {
                    continue 
                }
                if ($FileObject -is [System.IO.DirectoryInfo]) {
                    continue
                }
                [void]$InstalledPrograms.Add([object]$FileObject)
            }
        }
    }

    $PathListResult = New-Object System.Collections.ArrayList
    ForEach ($InstalledProgram in $InstalledPrograms) {
        if (-not ($PathListResult -contains $InstalledProgram.FullName)) {
            [void]$InstalledProgramsResult.Add($InstalledProgram)
            [void]$PathListResult.Add($InstalledProgram.FullName)
        }
    }

    if ($Filtered) {
        $InstalledProgramsResultFiltered = New-Object -TypeName System.Collections.ArrayList
        ForEach ($InstalledProgram in $InstalledProgramsResult) {
            if (-Not ($GlobalIgnoredPrograms -contains $InstalledProgram.Name)) {
                if (-Not (($InstalledProgram.Name -Like "Windows*") -Or ($InstalledProgram.Name -Like "Microsoft*"))) {
                    [void]$InstalledProgramsResultFiltered.Add($InstalledProgram)
                }
            }
        }
        return $InstalledProgramsResultFiltered
    }
    
    return $InstalledProgramsResult
}

function Get-ServiceList {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .PARAMETER Filtered
    Parameter description
    
    .PARAMETER FilterLevel
    FilterLevel = 0 - No filtering 
    FilterLevel = 1 - Exclude 'Services with empty ImagePath'
    FilterLevel = 2 - Exclude 'Services with empty ImagePath' + 'Drivers' 
    FilterLevel = 3 - Exclude 'Services with empty ImagePath' + 'Drivers' + 'Known services' 
    
    .EXAMPLE
    An example
    
    .NOTES
    Service types: KernelDriver(1), FileSystemDriver(2), Adapter(4), RecognizerDriver(8), Win32OwnProcess(16), Win32ShareProcess(32), InteractiveProcess(256)
    #>
    
    [CmdletBinding()] param(
        [ValidateSet(0,1,2,3)]
        [int]
        $FilterLevel = 0
    )

    $ServiceListResult = New-Object -TypeName System.Collections.ArrayList

    $RegAllServices = Get-ChildItem -path "Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services" 

    ForEach ($RegService in $RegAllServices) {

        $Properties = Get-ItemProperty -Path $RegService.PSPath -ErrorAction SilentlyContinue -ErrorVariable GetItemPropertyError
        if ($GetItemPropertyError) {
            # If an error occurred, skip the current item 
            continue 
        } 

        $ServiceItem = New-Object -TypeName PSObject 
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Properties.PSChildName
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "DisplayName" -Value $Properties.DisplayName
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "User" -Value $Properties.ObjectName 
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "ImagePath" -Value $Properties.ImagePath 
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "StartMode" -Value $(Convert-ServiceStartModeToString -StartMode $Properties.Start)
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "Type" -Value $(Convert-ServiceTypeToString -ServiceType $Properties.Type)
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "RegistryKey" -Value $RegService.Name
        $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "RegistryPath" -Value $RegService.PSPath 

        # FilterLevel = 0 - Add the service to the list and go to the next one 
        if ($FilterLevel -eq 0) {
            [void]$ServiceListResult.Add($ServiceItem) 
            continue 
        }

        if ($Properties.ImagePath -and (-not ($Properties.ImagePath.trim() -eq ''))) {
            # FilterLevel = 1 - Add the service to the list of its ImagePath is not empty
            if ($FilterLevel -le 1) {
                [void]$ServiceListResult.Add($ServiceItem)
                continue 
            }

            if ($Properties.Type -gt 8) {
                # FilterLevel = 2 - Add the service to the list if it's not a driver 
                if ($FilterLevel -le 2) {
                    [void]$ServiceListResult.Add($ServiceItem) 
                    continue
                }

                if (-not (Test-IsKnownService -ServiceName $Properties.PSChildName)) {
                    # FilterLevel = 3 - Add the service if it's not a built-in Windows service 
                    if ($FilterLevel -le 3) {
                        [void]$ServiceListResult.Add($ServiceItem) 
                        continue
                    }
                }
            }
        } 
    }

    return $ServiceListResult
}

function Get-ModifiablePath {
    <#
        .SYNOPSIS
    
            Parses a passed string containing multiple possible file/folder paths and returns
            the file paths where the current user has modification rights.
    
            Author: @harmj0y
            License: BSD 3-Clause
    
        .DESCRIPTION
    
            Takes a complex path specification of an initial file/folder path with possible
            configuration files, 'tokenizes' the string in a number of possible ways, and
            enumerates the ACLs for each path that currently exists on the system. Any path that
            the current user has modification rights on is returned in a custom object that contains
            the modifiable path, associated permission set, and the IdentityReference with the specified
            rights. The SID of the current user and any group he/she are a part of are used as the
            comparison set against the parsed path DACLs.
    
        .PARAMETER Path
    
            The string path to parse for modifiable files. Required
    
        .PARAMETER LiteralPaths
    
            Switch. Treat all paths as literal (i.e. don't do 'tokenization').
    
        .EXAMPLE
    
            PS C:\> '"C:\Temp\blah.exe" -f "C:\Temp\config.ini"' | Get-ModifiablePath
    
            Path                       Permissions                IdentityReference
            ----                       -----------                -----------------
            C:\Temp\blah.exe           {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
            C:\Temp\config.ini         {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
    
        .EXAMPLE
    
            PS C:\> Get-ChildItem C:\Vuln\ -Recurse | Get-ModifiablePath
    
            Path                       Permissions                IdentityReference
            ----                       -----------                -----------------
            C:\Vuln\blah.bat           {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
            C:\Vuln\config.ini         {ReadAttributes, ReadCo... NT AUTHORITY\Authentic...
            ...
    #>
    
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$True)]
        [Alias('FullName')]
        [String[]]
        $Path,

        [Switch]
        $LiteralPaths
    )

    BEGIN {
        # # false positives ?
        # $Excludes = @("MsMpEng.exe", "NisSrv.exe")

        # from http://stackoverflow.com/questions/28029872/retrieving-security-descriptor-and-getting-number-for-filesystemrights
        $AccessMask = @{
            [uint32]'0x80000000' = 'GenericRead'
            [uint32]'0x40000000' = 'GenericWrite'
            [uint32]'0x20000000' = 'GenericExecute'
            [uint32]'0x10000000' = 'GenericAll'
            [uint32]'0x02000000' = 'MaximumAllowed'
            [uint32]'0x01000000' = 'AccessSystemSecurity'
            [uint32]'0x00100000' = 'Synchronize'
            [uint32]'0x00080000' = 'WriteOwner'
            [uint32]'0x00040000' = 'WriteDAC'
            [uint32]'0x00020000' = 'ReadControl'
            [uint32]'0x00010000' = 'Delete'
            [uint32]'0x00000100' = 'WriteAttributes'
            [uint32]'0x00000080' = 'ReadAttributes'
            [uint32]'0x00000040' = 'DeleteChild'
            [uint32]'0x00000020' = 'Execute/Traverse'
            [uint32]'0x00000010' = 'WriteExtendedAttributes'
            [uint32]'0x00000008' = 'ReadExtendedAttributes'
            [uint32]'0x00000004' = 'AppendData/AddSubdirectory'
            [uint32]'0x00000002' = 'WriteData/AddFile'
            [uint32]'0x00000001' = 'ReadData/ListDirectory'
        }

        $UserIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
        $CurrentUserSids = $UserIdentity.Groups | Select-Object -ExpandProperty Value
        $CurrentUserSids += $UserIdentity.User.Value

        $TranslatedIdentityReferences = @{}
    }

    PROCESS {

        ForEach($TargetPath in $Path) {

            $CandidatePaths = @()

            # possible separator character combinations
            $SeparationCharacterSets = @('"', "'", ' ', "`"'", '" ', "' ", "`"' ")

            if($PSBoundParameters['LiteralPaths']) {

                $TempPath = $([System.Environment]::ExpandEnvironmentVariables($TargetPath))

                if(Test-Path -Path $TempPath -ErrorAction SilentlyContinue) {
                    $CandidatePaths += Resolve-Path -Path $TempPath | Select-Object -ExpandProperty Path
                }
                else {
                    # if the path doesn't exist, check if the parent folder allows for modification
                    try {
                        $ParentPath = Split-Path $TempPath -Parent
                        if($ParentPath -and (Test-Path -Path $ParentPath -ErrorAction SilentlyContinue)) {
                            $CandidatePaths += Resolve-Path -Path $ParentPath -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path
                        }
                    }
                    catch {
                        # because Split-Path doesn't handle -ErrorAction SilentlyContinue nicely
                    }
                }
            }
            else {
                ForEach($SeparationCharacterSet in $SeparationCharacterSets) {
                    $TargetPath.Split($SeparationCharacterSet) | Where-Object {$_ -and ($_.trim() -ne '')} | ForEach-Object {

                        if(($SeparationCharacterSet -notmatch ' ')) {

                            $TempPath = $([System.Environment]::ExpandEnvironmentVariables($_)).Trim()

                            # if the path is actually an option like '/svc', skip it 
                            # it will prevent a lot of false positives but it might also skip vulnerable paths in some particular cases 
                            # though, it's more common to see options like '/svc' than file paths like '/ProgramData/something' in Windows 
                            if ($TempPath -Like "/*") { continue }

                            if($TempPath -and ($TempPath -ne '')) {
                                if(Test-Path -Path $TempPath -ErrorAction SilentlyContinue) {
                                    # if the path exists, resolve it and add it to the candidate list
                                    $CandidatePaths += Resolve-Path -Path $TempPath | Select-Object -ExpandProperty Path
                                }

                                else {
                                    # if the path doesn't exist, check if the parent folder allows for modification
                                    try {
                                        $ParentPath = (Split-Path -Path $TempPath -Parent).Trim()
                                        if($ParentPath -and ($ParentPath -ne '') -and (Test-Path -Path $ParentPath )) {
                                            $CandidatePaths += Resolve-Path -Path $ParentPath | Select-Object -ExpandProperty Path
                                        }
                                    }
                                    catch {
                                        # trap because Split-Path doesn't handle -ErrorAction SilentlyContinue nicely
                                    }
                                }
                            }
                        }
                        else {
                            # if the separator contains a space
                            $CandidatePaths += Resolve-Path -Path $([System.Environment]::ExpandEnvironmentVariables($_)) -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path | ForEach-Object {$_.Trim()} | Where-Object {($_ -ne '') -and (Test-Path -Path $_)}
                        }
                    }
                }
            }

            $CandidatePaths | Sort-Object -Unique | ForEach-Object {
                $CandidatePath = $_

                Get-Acl -Path $CandidatePath | Select-Object -ExpandProperty Access | Where-Object {($_.AccessControlType -match 'Allow')} | ForEach-Object {

                    $FileSystemRights = $_.FileSystemRights.value__

                    $Permissions = $AccessMask.Keys | Where-Object { $FileSystemRights -band $_ } | ForEach-Object { $accessMask[$_] }

                    # the set of permission types that allow for modification
                    $Comparison = Compare-Object -ReferenceObject $Permissions -DifferenceObject @('GenericWrite', 'GenericAll', 'MaximumAllowed', 'WriteOwner', 'WriteDAC', 'WriteData/AddFile', 'AppendData/AddSubdirectory') -IncludeEqual -ExcludeDifferent

                    if($Comparison) {
                        if ($_.IdentityReference -notmatch '^S-1-5.*' -and $_.IdentityReference -notmatch '^S-1-15-.*') {
                            if(-not ($TranslatedIdentityReferences[$_.IdentityReference])) {
                                # translate the IdentityReference if it's a username and not a SID
                                $IdentityUser = New-Object System.Security.Principal.NTAccount($_.IdentityReference)
                                $TranslatedIdentityReferences[$_.IdentityReference] = $IdentityUser.Translate([System.Security.Principal.SecurityIdentifier]) | Select-Object -ExpandProperty Value
                            }
                            $IdentitySID = $TranslatedIdentityReferences[$_.IdentityReference]
                        }
                        else {
                            $IdentitySID = $_.IdentityReference
                        }

                        if($CurrentUserSids -contains $IdentitySID) {
                            New-Object -TypeName PSObject -Property @{
                                ModifiablePath = $CandidatePath
                                IdentityReference = $_.IdentityReference
                                Permissions = $Permissions
                            }
                        }
                    }
                }
            }
        }
    }
}

function Get-ModifiableRegistryPath {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$True)]
        [String[]]
        $Path
    )

    BEGIN {
        # # false positives ?
        # $Excludes = @("MsMpEng.exe", "NisSrv.exe")

        # from http://stackoverflow.com/questions/28029872/retrieving-security-descriptor-and-getting-number-for-filesystemrights
        $AccessMask = @{
            [uint32]'0x80000000' = 'GenericRead'
            [uint32]'0x40000000' = 'GenericWrite'
            [uint32]'0x20000000' = 'GenericExecute'
            [uint32]'0x10000000' = 'GenericAll'
            [uint32]'0x02000000' = 'MaximumAllowed'
            [uint32]'0x01000000' = 'AccessSystemSecurity'
            [uint32]'0x00100000' = 'Synchronize'
            [uint32]'0x00080000' = 'WriteOwner'
            [uint32]'0x00040000' = 'WriteDAC'
            [uint32]'0x00020000' = 'ReadControl'
            [uint32]'0x00010000' = 'Delete'
            [uint32]'0x00000100' = 'WriteAttributes'
            [uint32]'0x00000080' = 'ReadAttributes'
            [uint32]'0x00000040' = 'DeleteChild'
            [uint32]'0x00000020' = 'Execute/Traverse'
            [uint32]'0x00000010' = 'WriteExtendedAttributes'
            [uint32]'0x00000008' = 'ReadExtendedAttributes'
            [uint32]'0x00000004' = 'AppendData/AddSubdirectory'
            [uint32]'0x00000002' = 'WriteData/AddFile'
            [uint32]'0x00000001' = 'ReadData/ListDirectory'
        }

        $UserIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
        $CurrentUserSids = $UserIdentity.Groups | Select-Object -ExpandProperty Value
        $CurrentUserSids += $UserIdentity.User.Value

        $TranslatedIdentityReferences = @{}
    }

    PROCESS {
        $KeyAcl = Get-Acl -Path $Path -ErrorAction SilentlyContinue -ErrorVariable GetAclError
        if (-not $GetAclError) {
            $KeyAcl | Select-Object -ExpandProperty Access | Where-Object {($_.AccessControlType -match 'Allow')} | ForEach-Object {

                $RegistryRights = $_.RegistryRights.value__

                $Permissions = $AccessMask.Keys | Where-Object { $RegistryRights -band $_ } | ForEach-Object { $accessMask[$_] }

                # the set of permission types that allow for modification
                $Comparison = Compare-Object -ReferenceObject $Permissions -DifferenceObject @('GenericWrite', 'GenericAll', 'MaximumAllowed', 'WriteOwner', 'WriteDAC', 'WriteData/AddFile', 'AppendData/AddSubdirectory') -IncludeEqual -ExcludeDifferent

                if($Comparison) {
                    if ($_.IdentityReference -notmatch '^S-1-5.*') {
                        if(-not ($TranslatedIdentityReferences[$_.IdentityReference])) {
                            # translate the IdentityReference if it's a username and not a SID
                            $IdentityUser = New-Object System.Security.Principal.NTAccount($_.IdentityReference)
                            $TranslatedIdentityReferences[$_.IdentityReference] = $IdentityUser.Translate([System.Security.Principal.SecurityIdentifier]) | Select-Object -ExpandProperty Value
                        }
                        $IdentitySID = $TranslatedIdentityReferences[$_.IdentityReference]
                    }
                    else {
                        $IdentitySID = $_.IdentityReference
                    }

                    if($CurrentUserSids -contains $IdentitySID) {
                        New-Object -TypeName PSObject -Property @{
                            ModifiablePath = $Path
                            IdentityReference = $_.IdentityReference
                            Permissions = $Permissions
                        }
                    }
                }
            }
        }
    } 
}
#endregion Helpers 


# ----------------------------------------------------------------
# Checks  
# ----------------------------------------------------------------
#region Checks 
# ----------------------------------------------------------------
# BEGIN MISC   
# ----------------------------------------------------------------
function Invoke-SystemInfoCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    https://techthoughts.info/windows-version-numbers/
    #>
    
    [CmdletBinding()] param()

    $Item = Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion" 

    $SystemInfoResult = New-Object -TypeName PSObject 

    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "ProductName" -Value $Item.ProductName
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Major" -Value $Item.CurrentMajorVersionNumber
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Minor" -Value $Item.CurrentMinorVersionNumber
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Release" -Value $Item.ReleaseId
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Build" -Value $Item.CurrentBuild
    $SystemInfoResult | Add-Member -MemberType NoteProperty -Name "Revision" -Value $Item.UBR

    $FullVersion = "$($Item.CurrentMajorVersionNumber).$($Item.CurrentMinorVersionNumber).$($Item.CurrentBuild) Version $($Item.ReleaseId) ($($Item.CurrentBuild).$($Item.UBR))"

    Write-Message -Level Info "OS Name: $($Item.ProductName)"
    Write-Message -Level Info "OS Version: $($FullVersion)"
    
    return $SystemInfoResult
}

function Invoke-SystemStartupHistoryCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .PARAMETER TimeSpanInDays
    Parameter description
    
    .EXAMPLE
    An example
    
    .NOTES
    Event ID 6005: The Event log service was started, i.e. system startup theoretically.
    #>
    
    [CmdletBinding()] param(
        [int]
        $TimeSpanInDays = 31
    )

    $SystemStartupHistoryResult = New-Object -TypeName System.Collections.ArrayList

    $StartDate = (Get-Date).AddDays(-$TimeSpanInDays)
    $EndDate = Get-Date
    $TimeSpan = New-TimeSpan -Start $StartDate -End $EndDate

    $StartupEvents = Get-EventLog -LogName "System" -EntryType "Information" -After $StartDate -Before $EndDate | Where-Object {$_.EventID -eq 6005}

    ForEach ($Event in $StartupEvents) {
        $SystemStartupHistoryItem = New-Object -TypeName PSObject 
        $SystemStartupHistoryItem | Add-Member -MemberType "NoteProperty" -Name "Time" -Value "$(Convert-DateToString -Date $Event.TimeGenerated)"
        $SystemStartupHistoryItem | Add-Member -MemberType "NoteProperty" -Name "Message" -Value "$($Event.Message)"
        [void]$SystemStartupHistoryResult.Add($SystemStartupHistoryItem)
    }

    if (([object[]]$SystemStartupHistoryResult).Length -gt 0) {
        
        Write-Message -Level Info "Found $(([object[]]$SystemStartupHistoryResult).Length) startup event(s) in the last $($TimeSpan.Days) days."
        Write-Message -Level Info "Last startup time was: $($SystemStartupHistoryResult[0].Time)"

        if ($StartupEvents.Length -gt 10) {
            Write-Message -Level Success "The machine seems to be frequently rebooted. Showing last 10 events."
            For ($i = 0; $i -lt 10; $i++) {
                $GlobalIndentLevel +=1
                Write-Message -Level Info "Startup event: $(Convert-DateToString -Date $StartupEvents[$i].TimeGenerated)"
                $GlobalIndentLevel -=1
            }
        } 

    } else {
        Write-Message -Level Warning "Didn't find any startup event in the last $($TimeSpan.Days) days."

        $LastStartupEvent = Get-EventLog -LogName "System" -EntryType "Information" -Newest 1 -InstanceId 2147489653

        if ($LastStartupEvent) {
            Write-Message -Level Info "Last startup time was: $(Convert-DateToString -Date $LastStartupEvent.TimeGenerated)."
        }
    }

    return $SystemStartupHistoryResult
}

function Invoke-SystemDrivesCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    General notes
    #>
    
    [CmdletBinding()] param()

    $Drives = Get-PSDrive -PSProvider "FileSystem"

    Write-Message -Level Info "Found $($Drives.Length) drives."
    ForEach ($Drive in $Drives) {
        $GlobalIndentLevel += 1
        Write-Message -Level Info "$($Drive.Root) - Display name: '$($Drive.DisplayRoot)' - Description: '$($Drive.Description)'"
        $GlobalIndentLevel -= 1
    }

    return $Drives 
}

function Invoke-LocalAdminGroupCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    S-1-5-32-544 = SID of the local admin group 
    S-1-5-21-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxx-500 = SID of the default local admin 
    #>

    [CmdletBinding()] param()

    $LocalAdminGroupResult = New-Object System.Collections.ArrayList 

    $LocalAdminGroup = Get-LocalGroup -SID "S-1-5-32-544" -ErrorAction SilentlyContinue 
    $LocalAdmins = Get-LocalGroupMember -Group $LocalAdminGroup -ErrorAction SilentlyContinue -ErrorVariable GetLocalGroupMemberError

    if (-not $GetLocalGroupMemberError) {
        $GroupClassName = $LocalAdminGroup.ObjectClass 

        Write-Message -Level Info "The local group '$($LocalAdminGroup.Name)' has $($LocalAdmins.Length) members (users/groups)."

        ForEach ($LocalAdmin in $LocalAdmins) {
            $GlobalIndentLevel += 1
            $ItemName = ""
            $ItemType = $LocalAdmin.ObjectClass
            $ItemIsLocal = $True 
            $ItemIsEnabled = $True 
            $LocalAdminGroupResultItem = New-Object -TypeName PSObject
            if  ($LocalAdmin.PrincipalSource -eq "Local") {
                $ItemIsLocal = $True
                if ($LocalAdmin.ObjectClass -eq $GroupClassName) {
                    $LocalGroup = Get-LocalGroup -SID $LocalAdmin.SID 
                    $ItemName = $LocalGroup.Name
                    Write-Message -Level Info "Local group '$($LocalGroup.Name)'."
                } else {
                    $LocalAccount = Get-LocalUser -SID $LocalAdmin.SID 
                    $ItemName = $LocalAccount.Name
                    if ($LocalAccount.Enabled) {
                        $ItemIsEnabled = $True 
                        Write-Message -Level Info "Local user '$($LocalAccount.Name)'."
                    } else {
                        $ItemIsEnabled = $False 
                        Write-Message -Level Warning "Local user '$($LocalAccount.Name)' is disabled."
                    }
                }
            } else {
                $ItemIsLocal = $False
                $ItemName = $LocalAdmin.Name
                if ($LocalAdmin.ObjectClass -eq $GroupClassName) {
                    Write-Message -Level Info "Domain group/user '$($LocalAdmin.Name)'."
                }
            }

            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $ItemName
            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "Type" -Value $ItemType
            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "IsLocal" -Value $ItemIsLocal  
            $LocalAdminGroupResultItem | Add-Member -MemberType "NoteProperty" -Name "IsEnabled" -Value $ItemIsEnabled 
            [void]$LocalAdminGroupResult.Add($LocalAdminGroupResultItem)

            $GlobalIndentLevel -= 1
        }
    } else {
        Write-Message -Level Error "An unknown error occurred."
        Write-Debug -Message $GetLocalGroupMemberError.Exception 
    }

    return $LocalAdminGroupResult
}

function Invoke-MachineRoleCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    WinNT = workstation
    LanmanNT = domain controller
    ServerNT = server
    #>
    
    [CmdletBinding()] param()

    $MachineRoleResult = New-Object -TypeName PSObject 

    $Item = Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\ProductOptions"
    
    $RoleFriendlyName = ""

    if ($Item.ProductType -eq "WinNT") {
        $RoleFriendlyName = "WorkStation"
    } elseif ($Item.ProducType -eq "LanmanNT") {
        $RoleFriendlyName = "Domain Controller"
    } elseif ($Item.ProductType -eq "ServerNT") {
        $RoleFriendlyName = "Server"
    } 

    if (($RoleFriendlyName -eq "")) {
        $MachineRoleResult = $Null 
    } else {
        $MachineRoleResult | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Item.ProductType
        $MachineRoleResult | Add-Member -MemberType "NoteProperty" -Name "Role" -Value $RoleFriendlyName
    }

    if ($MachineRoleResult) {
        Write-Message -Level Info "Machine type: '$($RoleFriendlyName)'"
    } else {
        Write-Message -Level Warning "Machine role is unknown."
    }

    return $MachineRoleResult
}

function Invoke-WindowsUpdateCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    General notes
    #>
    
    [CmdletBinding()] param()

    $WindowsUpdateResult = New-Object -TypeName PSObject 

    $WindowsUpdate = (New-Object -ComObject "Microsoft.Update.AutoUpdate").Results

    $EndDate = Get-Date 
    $StartDate = $WindowsUpdate.LastInstallationSuccessDate
    $TimeSpan = New-TimeSpan -Start $StartDate -End $EndDate 

    if ($TimeSpan.Days -ge 30) {
        $WindowsUpdateResult = $WindowsUpdate
    } else {
        $WindowsUpdateResult = $Null 
    }

    Write-Message -Level Info "Last successful update time: $(Convert-DateToString -Date $WindowsUpdate.LastInstallationSuccessDate)"
    
    if ($WindowsUpdateResult) {
        Write-Message -Level Success "Last update is more than 1 month old."
    } else {
        Write-Message -Level Warning "The machine seems to be quite up-to-date."        
    }

    return $WindowsUpdateResult
}

function Invoke-RegistryAlwaysInstallElevatedCheck {
   
    [CmdletBinding()]
    Param()

    $RegistryAlwaysInstallElevatedResult = New-Object -TypeName System.Collections.ArrayList

    if (Test-Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer" -ErrorAction SilentlyContinue) {

        $HKLMval = (Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue)
        if ($HKLMval.AlwaysInstallElevated -and ($HKLMval.AlwaysInstallElevated -ne 0)){
            # HKLM:AlwaysInstallElevated is enabled 
            $RegistryAlwaysInstallElevatedItem = New-Object -TypeName PSObject 
            $RegistryAlwaysInstallElevatedItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer"
            $RegistryAlwaysInstallElevatedItem | Add-Member -MemberType "NoteProperty" -Name "Value" -Value $HKLMval.AlwaysInstallElevated 
            [void]$RegistryAlwaysInstallElevatedResul.Add($RegistryAlwaysInstallElevatedItem)
        } 

        $HKCUval = (Get-ItemProperty -Path "Registry::HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue)
        if ($HKCUval.AlwaysInstallElevated -and ($HKCUval.AlwaysInstallElevated -ne 0)){
            # HKCU:AlwaysInstallElevated is enabled 
            $RegistryAlwaysInstallElevatedItem = New-Object -TypeName PSObject
            $RegistryAlwaysInstallElevatedItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer"
            $RegistryAlwaysInstallElevatedItem | Add-Member -MemberType "NoteProperty" -Name "Value" -Value $HKLMval.AlwaysInstallElevated 
            [void]$RegistryAlwaysInstallElevatedResul.Add($RegistryAlwaysInstallElevatedItem)
        } 
    } 

    if (([object[]]$RegistryAlwaysInstallElevatedResult).Length -gt 0) {
        Write-Message -Level Success "The 'AlwaysInstallElevated' key exists and is enabled."
        ForEach ($Result in $RegistryAlwaysInstallElevatedResult) {
            $GlobalIndentLevel += 1
            Write-Message -Level Success "Path: $($Result.Name) - Value: $($Result.Value)"
            $GlobalIndentLevel -= 1
        }
    } else {
        Write-Message -Level Warning "The key either doesn't exist or is not enabled."
    }

    return $RegistryAlwaysInstallElevatedResult
}

# ----------------------------------------------------------------
# END MISC   
# ----------------------------------------------------------------

# ----------------------------------------------------------------
# BEGIN PRIVILEGES   
# ----------------------------------------------------------------
function Invoke-UserPrivilegesCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    TODO: Rewrite this to avoid a call to an external tool 
    TODO: Add a description on how to exploit each priv 

    Interesting privileges 
        - SeAssignPrimaryTokenPrivilege
        - SeImpersonatePrivilege
        - SeCreateTokenPrivilege
        - SeDebugPrivilege
        - SeLoadDriverPrivilege
        - SeRestorePrivilege
        - SeTakeOwnershipPrivilege
    #>

    [CmdletBinding()] param()

    $UserPrivilegesResult = New-Object -TypeName System.Collections.ArrayList

    $Username = "$($env:USERDOMAIN)\$($env:USERNAME)"

    $Privileges = "SeAssignPrimaryTokenPrivilege", "SeImpersonatePrivilege", "SeCreateTokenPrivilege", "SeDebugPrivilege", "SeLoadDriverPrivilege", "SeRestorePrivilege", "SeTakeOwnershipPrivilege", "SeTcbPrivilege", "SeShutdownPrivilege", "SeBackupPrivilege"

    $Output = (& whoami /priv | Out-String) 
        
    $Lines = $Output.Split("`n")
    ForEach ($Line in $Lines) {
        If ($Line -Like "*Se*Privilege*") {
            $Priv = $Line.Split(' ')[0]
            if ($Privileges -contains $Priv) {
                $UserPrivilegeItem = New-Object -TypeName PSObject 
                $UserPrivilegeItem | Add-Member -MemberType "NoteProperty" -Name "Username" -Value $Username
                $UserPrivilegeItem | Add-Member -MemberType "NoteProperty" -Name "Privilege" -Value $Priv
                $UserPrivilegesResult.Add([object]$UserPrivilegeItem)
            }
        }
    }

    if (([object[]]$UserPrivilegesResult).Length -gt 0) {
        Write-Message -Level Info "User '$($Username)' user has $(([object[]]$UserPrivilegesResult).Length) potentially interesting privilege(s)."
        $GlobalIndentLevel += 1
        ForEach ($Result in $UserPrivilegesResult) {
            Write-Message -Level Success "$($Result.Privilege)"
        }
        $GlobalIndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any interesting privilege."
    }

    return $UserPrivilegesResult
}
# ----------------------------------------------------------------
# END PRIVILEGES    
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN CREDENTIALS     
# ----------------------------------------------------------------
function Invoke-WinlogonCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    General notes
    #>

    [CmdletBinding()] param()

    #$WinlogonResult = New-Object -TypeName PSObject 
    $WinlogonResult = New-Object -TypeName System.Collections.ArrayList
    
    $Item = Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"

    if ($Item.DefaultDomainName -Or $Item.DefaultUserName -Or $Item.DefaultPassword) {
        $WinlogonItem = New-Object -TypeName PSObject 
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Domain" -Value $Item.DefaultDomainName
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Username" -Value $Item.DefaultUserName
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Password" -Value $Item.DefaultPassword
        [void]$WinlogonResult.Add($WinlogonItem)
    } 

    if ($Item.AltDefaultDomainName -Or $Item.AltDefaultUserName -Or $Item.AltDefaultPassword) {
        $WinlogonItem = New-Object -TypeName PSObject 
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Domain" -Value $Item.AltDefaultDomainName
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Username" -Value $Item.AltDefaultUserName
        $WinlogonItem | Add-Member -MemberType "NoteProperty" -Name "Password" -Value $Item.AltDefaultPassword
        [void]$WinlogonResult.Add($WinlogonItem)
    }

    if (([object[]]$WinlogonResult).Length -gt 0) {
        Write-Message -Level Info "Found $(([object[]]$WinlogonResult).Length) credential(s)."
        $GlobalIndentLevel += 1
        ForEach ($Result in $WinlogonResult) {
            $OutString = ""
            if ($Result.Domain) { $OutString += "$($Result.Domain)\" } else { $OutString += "(null)\" }
            if ($Result.Username) { $OutString += "$($Result.Username)" } else { $OutString += "(null)" }
            if ($Result.Password) { $OutString += ":$($Result.Password)"} else { $OutString += ":(null)" }

            if ($Result.Password) {
                Write-Message -Level Success $OutString
            } else { 
                Write-Message -Level Info $OutString
            }
        }
        $GlobalIndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find anything."
    }

    return $WinlogonResult
}

function Invoke-CredentialFilesCheck {
    <#
    .SYNOPSIS
    Short description
    
    .DESCRIPTION
    Long description
    
    .EXAMPLE
    An example
    
    .NOTES
    Get file content with https://github.com/AlessandroZ/LaZagne ???
    #>
    
    [CmdletBinding()] param()

    function Get-CredentialFiles {
        [CmdletBinding()] param(
            [string]
            $Path 
        )
        $Result = New-Object System.Collections.ArrayList
        $Items = Get-ChildItem -Hidden -Path $Path -ErrorAction SilentlyContinue -ErrorVariable Errors 
        if (-not $Errors) {
            ForEach ($Item in $Items) {
                $FullPath = Join-Path -Path $Path -ChildPath $Item.Name 
                $FileObject = New-Object -TypeName PSObject 
                $FileObject | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Item.Name
                $FileObject | Add-Member -MemberType "NoteProperty" -Name "FullPath" -Value $FullPath
                [void]$Result.Add($FileObject)
            }
        }
        return $Result
    }

    $CredentialFilesResult = New-Object -TypeName System.Collections.ArrayList

    $PathLocalAppData = Join-Path -Path $env:LOCALAPPDATA -ChildPath "Microsoft\Credentials"
    $PathAppData = Join-Path -Path $env:APPDATA -ChildPath "Microsoft\Credentials"

    [void]$CredentialFilesResult.AddRange([object[]]$(Get-CredentialFiles -Path $PathLocalAppData))
    [void]$CredentialFilesResult.AddRange([object[]]$(Get-CredentialFiles -Path $PathAppData))

    if (([object[]]$CredentialFilesResult).Length -gt 0) {
        Write-Message -Level Info "Found $(([object[]]$CredentialFilesResult).Length) credential files"
        $GlobalIndentLevel += 1
        ForEach ($CredentialFile in $CredentialFilesResult) {
            Write-Message -Level Info "$($CredentialFile.FullPath)"
        }
        $GlobalIndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any credential file."
    }

    return $CredentialFilesResult
}
# ----------------------------------------------------------------
# END CREDENTIALS     
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN SENSITIVE FILES 
# ----------------------------------------------------------------
function Invoke-SamBackupFilesCheck {
    
    [CmdletBinding()] param()

    $SamBackupFiles = New-Object System.Collections.ArrayList

    $ArrayOfPaths = New-Object System.Collections.ArrayList 
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "repair\SAM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\RegBack\SAM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\SAM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "repair\system"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\SYSTEM"))
    [void]$ArrayOfPaths.Add($(Join-Path -Path $env:SystemRoot -ChildPath "System32\config\RegBack\system"))

    ForEach ($Path in [string[]]$ArrayOfPaths) {
        if (Test-Path -Path $Path) { 
            $SamBackupFile = New-Object -TypeName PSObject   
            Get-Content -Path $Path -ErrorAction SilentlyContinue -ErrorVariable GetContentError | Out-Null 
            if (-not $GetContentError) {
                $SamBackupFile | Add-Member -MemberType "NoteProperty" -Name "Path" -Value $Path 
                [void]$SamBackupFiles.Add($SamBackupFile) 
            } 
        }
    }

    if (([object[]]$SamBackupFiles).Length -gt 0) {
        Write-Message -Level Info "Found $(([object[]]$SamBackupFiles).Length) readable file(s)."
        $GlobalIndentLevel +=1
        ForEach ($File in $SamBackupFiles) {
            Write-Message -Level Success "File: $($File.Path)"
        }
        $GlobalIndentLevel -=1
    } else {
        Write-Message -Level Warning "Didn't find any readable file."
    }

    return $SamBackupFiles
}
# ----------------------------------------------------------------
# END SENSITIVE FILES 
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN INSTALLED PROGRAMS   
# ----------------------------------------------------------------
function Invoke-InstalledProgramsCheck {
    [CmdletBinding()] param()

    $InstalledProgramsResult = New-Object System.Collections.ArrayList 

    $Items = Get-InstalledPrograms -Filtered

    ForEach ($Item in $Items) {
        $CurrentFileName = $Item.Name 
        $CurrentFileFullname = $Item.FullName
        $AppItem = New-Object -TypeName PSObject 
        $AppItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $CurrentFileName
        $AppItem | Add-Member -MemberType "NoteProperty" -Name "FullPath" -Value $CurrentFileFullname
        [void]$InstalledProgramsResult.Add($AppItem)
    }

    $InstalledProgramsResultLen = ([object[]]$InstalledProgramsResult).Length
    if ($InstalledProgramsResultLen -gt 0) {
        Write-Message -Level Info "Found $(([object[]]$InstalledProgramsResult).Length) third-party applications."
        $GlobalIndentLevel += 1
        ForEach ($Result in $InstalledProgramsResult) {
            Write-Message -Level Info "Application: $($Result.Name) - Path: $($Result.FullPath)"
        }
        $GlobalIndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any third-party application."
    }
    
    return $InstalledProgramsResult
}

function Invoke-ModifiableProgramsCheck {
    [CmdletBinding()] param()

    $ModifiableProgramsResult = New-Object -TypeName System.Collections.ArrayList

    #$ModifiablePaths = New-Object -TypeName System.Collections.ArrayList
    $Items = Get-InstalledPrograms -Filtered

    Write-Message -Level Info "Searching for modifiable files/folders in $(([object[]]$Items).Length) applications..."

    $GlobalIndentLevel += 1
    ForEach ($Item in $Items) {
        #$SearchPath = New-Object -TypeName System.Collections.ArrayList
        #[void]$SearchPath.Add([string]$(Join-Path -Path $Item.FullName -ChildPath "\*")) # Do this to avoid the use of -Depth which is PSH3+
        #[void]$SearchPath.Add([string]$(Join-Path -Path $Item.FullName -ChildPath "\*\*")) # Do this to avoid the use of -Depth which is PSH3+
        #$ChildItems = Get-ChildItem -Path $SearchPath -ErrorAction SilentlyContinue -ErrorVariable GetChildItemError # Do this to avoid the use of -Depth which is PSH3+
        $ChildItems = $Item | Get-ChildItem -Recurse -Depth 2 -ErrorAction SilentlyContinue -ErrorVariable GetChildItemError 
        if (-not $GetChildItemError) {
            $ChildItems | ForEach-Object {
                if ($_ -is [System.IO.DirectoryInfo]) {
                    $IsDirectory = $True
                    $GetModifiablePathsResult = $_ | Get-ModifiablePath -LiteralPaths
                    if ($GetModifiablePathsResult) {
                        $ModifiableProgram = New-Object -TypeName PSObject 
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "ModifiablePath" -Value $GetModifiablePathsResult[0].ModifiablePath 
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IsDirectory" -Value $IsDirectory
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IdentityReference" -Value $GetModifiablePathsResult[0].IdentityReference 
                        $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "Permissions" -Value $GetModifiablePathsResult[0].Permissions 
                        [void]$ModifiableProgramsResult.Add([object]$ModifiableProgram)
                        Write-Message -Level Success "Found modifiable directory: $($_.FullName)"
                    }
                } else {
                    $IsDirectory = $False
                    # Check only .exe and .dll ???
                    # TODO: maybe consider other extensions 
                    if ($_.FullName -Like "*.exe" -or $_.FullName -Like "*.dll") {
                        $GetModifiablePathsResult = $_ | Get-ModifiablePath -LiteralPaths
                        ForEach($Result in $GetModifiablePathsResult) {
                            $ModifiableProgram = New-Object -TypeName PSObject 
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "ModifiablePath" -Value $Result.ModifiablePath 
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IsDirectory" -Value $IsDirectory
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "IdentityReference" -Value $Result.IdentityReference 
                            $ModifiableProgram | Add-Member -MemberType "NoteProperty" -Name "Permissions" -Value $Result.Permissions 
                            [void]$ModifiableProgramsResult.Add([object]$ModifiableProgram)
                            Write-Message -Level Success "Found modifiable file: $($_.FullName)"
                        }
                    }
                }
            }
        }
    }
    $GlobalIndentLevel -= 1

    if (([object[]]$ModifiableProgramsResult).Length -eq 0) {
        Write-Message -Level Warning "Didn't find any modifiable path."
    }

    return $ModifiableProgramsResult
}
# ----------------------------------------------------------------
# END INSTALLED PROGRAMS   
# ----------------------------------------------------------------


# ----------------------------------------------------------------
# BEGIN SERVICES   
# ----------------------------------------------------------------
function Invoke-InstalledServicesCheck {
    [CmdletBinding()] param()

    function Write-ArrayOfServices {
        [CmdletBinding()] param(
            [object[]]
            $Services
        )

        if (([object[]]$Services).Length -gt 0) {
            $User = $Services[0].User 
            if ($User -eq "LocalSystem") {
                Write-Message -Level Info "Found $(([object[]]$Services).Length) service(s) running as LocalSystem."
            } else {
                Write-Message -Level Info "Found $(([object[]]$Services).Length) other service(s)."
            }
            $GlobalIndentLevel += 1
            ForEach ($Service in $Services) {
                Write-Message -Level Info "Service: '$($Service.Name)' ($($Service.DisplayName)) - User: $($Service.User) - StartMode: $($Service.StartMode)"
            }
            $GlobalIndentLevel -= 1
        }
    }

    $InstalledServicesResult = New-Object -TypeName System.Collections.ArrayList

    # Get only third-party services 
    $FilteredServices = Get-ServiceList -FilterLevel 3

    Write-Message -Level Info "Found $(([object[]]$FilteredServices).Length) third-party services."

    $ServicesRunningAsSystem = New-Object -TypeName System.Collections.ArrayList
    $ServicesRunningAsOther = New-Object -TypeName System.Collections.ArrayList
    ForEach ($Service in $FilteredServices) {
        $Properties = Get-ItemProperty -Path $Service.RegistryPath -ErrorAction SilentlyContinue -ErrorVariable GetItemPropertyError 
        if (-not $GetItemPropertyError) {
            $ServiceItem = New-Object -TypeName PSObject 
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Properties.PSChildName
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "DisplayName" -Value $Properties.DisplayName
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "User" -Value $Properties.ObjectName 
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "ImagePath" -Value $Properties.ImagePath 
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "StartMode" -Value $(Convert-ServiceStartModeToString -StartMode $Properties.Start)
            $ServiceItem | Add-Member -MemberType "NoteProperty" -Name "Type" -Value $(Convert-ServiceTypeToString -ServiceType $Properties.Type)
            [void]$InstalledServicesResult.Add($ServiceItem)

            if ($Properties.ObjectName -eq "LocalSystem") {
                [void]$ServicesRunningAsSystem.Add($ServiceItem)
            } else {
                [void]$ServicesRunningAsOther.Add($ServiceItem)
            }
        }
    }

    Write-ArrayOfServices -Services $ServicesRunningAsSystem
    Write-ArrayOfServices -Services $ServicesRunningAsOther

    return $InstalledServicesResult
}

function Invoke-ServicesPermissionsRegistryCheck {
    [CmdletBinding()] param()
    
    $ServicesPermissionsRegistryResult = New-Object -TypeName System.Collections.ArrayList 

    # Get all services except the ones with an empty ImagePath or Drivers 
    $AllServices = Get-ServiceList -FilterLevel 2 

    ForEach ($Service in $AllServices) {
        $ModifiablePath = Get-ModifiableRegistryPath -Path $Service.RegistryPath
        if ($ModifiablePath) {
            $ModifiableService = New-Object -TypeName PSObject 
            $ModifiableService | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $Service.Name 
            $ModifiableService | Add-Member -MemberType "NoteProperty" -Name "ModifiablePath" -Value $Service.RegistryKey 
            $ModifiableService | Add-Member -MemberType "NoteProperty" -Name "IdentityReference" -Value $ModifiablePath.IdentityReference 
            $ModifiableService | Add-Member -MemberType "NoteProperty" -Name "Permissions" -Value $ModifiablePath.Permissions 
            [void]$ServicesPermissionsRegistryResult.Add([object]$ModifiableService) 
        }
    }

    if (([object[]]$ServicesPermissionsRegistryResult).Length -gt 0) {
        Write-Message -Level Info "Found $(([object[]]$ServicesPermissionsRegistryResult).Length) modifiable registry key(s)."
        $GlobalIndentLevel += 1
        ForEach ($Result in $ServicesPermissionsRegistryResult) {
            Write-Message -Level Success "Name: $($Result.Name) - Path: $($Result.ModifiablePath)"
        }
        $GlobalIndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any modifiable registry key."
    }

    return $ServicesPermissionsRegistryResult
}

function Invoke-ServicesUnquotedPathCheck {
    [CmdletBinding()] param()

    $ServicesUnquotedPathResult = New-Object -TypeName System.Collections.ArrayList 

    # Get all services which have a non-empty ImagePath
    $Services = Get-ServiceList -FilterLevel 1
    
    $PermissionsAddFile = @("WriteData/AddFile", "DeleteChild", "WriteDAC", "WriteOwner")
    $PermissionsAddFolder = @("AppendData/AddSubdirectory", "DeleteChild", "WriteDAC", "WriteOwner")

    ForEach ($Service in $Services) {
        $ImagePath = $Service.ImagePath.trim()

        # If the ImagePath doesn't start with a " or a ' 
        if (-not ($ImagePath.StartsWith("`"") -or $ImagePath.StartsWith("'"))) {
            
            # Extract the binpath from the ImagePath
            $BinPath = $ImagePath.SubString(0, $ImagePath.ToLower().IndexOf(".exe") + 4)

            # If the binpath contains spaces 
            If ($BinPath -match ".* .*") {
                $ModifiableFiles = $BinPath.split(' ') | Get-ModifiablePath

                $VulnPaths = @() 

                $ModifiableFiles | Where-Object {$_ -and $_.ModifiablePath -and ($_.ModifiablePath -ne '')} | Foreach-Object {
                     
                    $TempPath = $([System.Environment]::ExpandEnvironmentVariables($BinPath))
                    $TempPath = Split-Path -Path $TempPath -Parent 
                    while ($TempPath) 
                    {
                        try {
                            $ParentPath = Split-Path -Path $TempPath -Parent 
                            if ($ParentPath -eq $_.ModifiablePath) {
                                $PermissionsSet = $Null 
                                if (Test-Path -Path $TempPath) {
                                    # If the current folder exists, can we create files in it?
                                    #"Folder $($TempPath) exists, can we create files in $($ParentPath)???"
                                    $PermissionsSet = $PermissionsAddFile
                                } else {
                                    # The current folder doesn't exist, can we create it? 
                                    #"Folder $($TempPath) doesn't exist, can we create the folder $($ParentPath)???"
                                    $PermissionsSet = $PermissionsAddFolder 
                                }
                                ForEach ($Permission in $_.Permissions) {
                                    if ($PermissionsSet -contains $Permission) {
                                        $VulnPaths += $_
                                        break
                                    }
                                }
                                # We found the path returned by Get-ModifiablePath so we can exit the while loop 
                                break
                            }
                        } catch {
                            # because Split-Path doesn't handle -ErrorAction SilentlyContinue nicely
                            # exit safely to avoid an infinite loop 
                            break 
                        }
                        $TempPath = $ParentPath
                    }
                }

                if ($VulnPaths) {
                    $VulnService = $Service 
                    $VulnService | Add-Member -MemberType "NoteProperty" -Name "VulnPaths" -Value $VulnPaths
                    [void]$ServicesUnquotedPathResult.Add([object]$VulnService) 
                }
            }
        }
    }

    if (([object[]]$ServicesUnquotedPathResult).Length -gt 0) {

        Write-Message -Level Success "Found $(([object[]]$ServicesUnquotedPathResult).Length) vulnerable service(s)."

        $GlobalIndentLevel += 1
        ForEach ($Result in $ServicesUnquotedPathResult) {
            Write-Message -Level Info "Service: '$($Result.Name)' ($($Result.DisplayName)) running as '$($Result.User)' (StartMode: $($Result.StartMode))"
            Write-Message -Level Info "Image path: $($Result.ImagePath)"
            ForEach ($Path in $Result.VulnPaths) {
                Write-Message -Level Success "Modifiable path: $($Path.ModifiablePath)"
                $GlobalIndentLevel += 1
                Write-Message -Level Info "Identity Reference: $($Path.IdentityReference)"
                Write-Message -Level Info "Permissions:        $($Path.Permissions)"
                $GlobalIndentLevel -= 1
            }
        }
        $GlobalIndentLevel -= 1

    } else {
        Write-Message -Level Warning "Didn't find any vulnerable service."
    }

    return $ServicesUnquotedPathResult
}

function Invoke-ServicesImagePermissionsCheck {
    [CmdletBinding()] param()
    
    $ServicesImagePermissionsResult = New-Object -TypeName System.Collections.ArrayList 

    $Services = Get-ServiceList -FilterLevel 1

    ForEach ($Service in $Services) {

        $ModifiablePaths = $Service.ImagePath | Get-ModifiablePath

        if ($ModifiablePaths) {
            $VulnService = $Service
            $VulnService | Add-Member -MemberType "NoteProperty" -Name "VulnPaths" -Value $ModifiablePaths
            [void]$ServicesImagePermissionsResult.Add([object]$VulnService) 
        }
    }

    if (([object[]]$ServicesImagePermissionsResult).Length -gt 0) {
        Write-Message -Level Success "Found $(([object[]]$ServicesImagePermissionsResult).Length) potentially vulnerable service(s)."
        $GlobalIndentLevel += 1
        ForEach ($Result in $ServicesImagePermissionsResult) {
            Write-Message -Level Info "Service: '$($Result.Name)' ($($Result.DisplayName)) running as '$($Result.User)' (StartMode: $($Result.StartMode))"
            Write-Message -Level Info "Image path: $($Result.ImagePath)"
            ForEach ($Path in $Result.VulnPaths) {
                Write-Message -Level Success "Modifiable path: $($Path.ModifiablePath)"
                $GlobalIndentLevel += 1
                Write-Message -Level Info "Identity Reference: $($Path.IdentityReference)"
                Write-Message -Level Info "Permissions:        $($Path.Permissions)"
                $GlobalIndentLevel -= 1
            }
        }
        $GlobalIndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any vulnerable service."
    }

    return $ServicesImagePermissionsResult
}
# ----------------------------------------------------------------
# END SERVICES   
# ----------------------------------------------------------------

# ----------------------------------------------------------------
# END DLL HIJACKING   
# ----------------------------------------------------------------
function Invoke-DllHijackingCheck {
    [CmdletBinding()] param()
    
    $DllHijackingResult = New-Object -TypeName System.Collections.ArrayList

    $SystemPath = (Get-ItemProperty -Path "Registry::HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" -Name "Path").Path 
    $Paths = $SystemPath.Split(';')

    ForEach ($Path in $Paths) {
        if ($Path -and $Path -ne '') {
            $ModifiablePaths = $Path | Get-ModifiablePath -LiteralPaths 
            ForEach ($ModifiablePath in $ModifiablePaths) {
                if ($Null -ne $ModifiablePath.ModifiablePath) {
                    [void]$DllHijackingResult.Add([object]$ModifiablePath) 
                }
            }
        }
    }

    if (([object[]]$DllHijackingResult).Length -gt 0) {
        Write-Message -Level Success "Found $(([object[]]$DllHijackingResult).Length) vulnerable path(s)."
        $GlobalIndentLevel += 1
        ForEach ($Result in $DllHijackingResult) {
            Write-Message -Level Success "Path: $($Result.ModifiablePath)"
            $GlobalIndentLevel += 1
            Write-Message -Level Info "Identity Reference: $($Result.IdentityReference)"
            Write-Message -Level Info "Permissions:        $($Result.Permissions)"
            $GlobalIndentLevel -= 1
        }
        $GlobalIndentLevel -= 1
    } else {
        Write-Message -Level Warning "Didn't find any vulnerable path."
    }

    return $DllHijackingResult
}
# ----------------------------------------------------------------
# END DLL HIJACKING   
# ----------------------------------------------------------------
#endregion Checks

# ----------------------------------------------------------------
# Main  
# ----------------------------------------------------------------
#region Main
function Invoke-PrivescCheck {

    [CmdletBinding()] param()

    $Results = $Null ; $Results | Out-Null # Remove variable not used warning 

    "----------------------------------------------------------------"
    "|                          PRIVILEGES                          |"
    "----------------------------------------------------------------"

    "TEST: Checking user privileges"
    "DESC: Do we have any interesting privilege? e.g.: SeImpersonate, SeAssignPrimaryToken"
    $Results = Invoke-UserPrivilegesCheck
    #$Results | Format-List 

    Write-Host "`n"


    "----------------------------------------------------------------"
    "|                           SERVICES                           |"
    "----------------------------------------------------------------"

    "TEST: Listing third-party services"
    "DESC: Buil-in services are (usually) properly configured, what about third-party software?"
    $Results = Invoke-InstalledServicesCheck
    #$Results | Format-List

    Write-Host "`n"

    "TEST: Checking service permissions (registry)"
    "DESC: Can we modify the settings of a service in the registry."
    $Results = Invoke-ServicesPermissionsRegistryCheck
    #$Results | Format-List

    Write-Host "`n"

    #"Checking services permissions"
    #$Results = Invoke-ServicesPermissionsCheck
    #$Results | Format-List

    #Write-Host "`n"
    
    "TEST: Checking for unquoted service paths"
    "DESC: If a service is confgured with an unquoted path, we may potentially plant a binary in a parent folder."
    $Results = Invoke-ServicesUnquotedPathCheck
    #$Results | Format-List

    Write-Host "`n"

    "TEST: Checking service executable and argument permissions"
    "DESC: If we can somehow control the executable or one of its parameters, we could potentially hijack the service."
    $Results = Invoke-ServicesImagePermissionsCheck
    #$Results | Format-List

    Write-Host "`n"


    "----------------------------------------------------------------"
    "|                         DLL HIJACKING                        |"
    "----------------------------------------------------------------"

    "TEST: Checking system %PATH% for potentially hijackable DLL locations"
    "DESC: If we have write permissions in a %PATH% folder, we could potentially load a malicious DLL."
    $Results = Invoke-DllHijackingCheck
    #$Results | Format-List

    Write-Host "`n"

    "----------------------------------------------------------------"
    "|                        SENSITIVE FILES                       |"
    "----------------------------------------------------------------"

    "TEST: Checking SAM/SYSTEM backup files"
    "DESC: Is there any backup of the SAM/SYSTEM hives we can read?"
    $Results = Invoke-SamBackupFilesCheck
    #$Results | Format-List 

    Write-Host "`n"


    "----------------------------------------------------------------"
    "|                       INSTALLED PROGRAMS                     |"
    "----------------------------------------------------------------"
    "TEST: Listing installed programs except the ones from Microsoft"
    "DESC: Default application folders have proper permissions but what about third-party software?"
    $Results = Invoke-InstalledProgramsCheck
    #$Results | Format-List 

    Write-Host "`n"
    
    "TEST: Checking modifiable programs"
    "DESC: Replace an existing executable with a malicious one? Or DLL planting/proxying?"
    $Results = Invoke-ModifiableProgramsCheck
    #$Results | Format-List

    Write-Host "`n"


    "----------------------------------------------------------------"
    "|                          CREDENTIALS                         |"
    "----------------------------------------------------------------"

    "TEST: Checking WinLogon registry key"
    "DESC: A password is potentially stored there (you never know ^^)."
    $Results = Invoke-WinlogonCheck
    #$Results | Format-List 

    Write-Host "`n"

    "TEST: Checking Credential files"
    "DESC: Credentials can be found in the current user's home folder."
    $Results = Invoke-CredentialFilesCheck
    #$Results | Format-List

    Write-Host "`n"


    "----------------------------------------------------------------"
    "|                              MISC                            |"
    "----------------------------------------------------------------"

    "TEST: Checking system version"
    "DESC: Is the system up to date?"
    $Results = Invoke-SystemInfoCheck
    #$Results | Format-List 

    Write-Host "`n"

    "TEST: Checking machine role (Workstation, server, DC)"
    "DESC: We want to know what we are dealing with."
    $Results = Invoke-MachineRoleCheck 
    #$Results | Format-List 

    Write-Host "`n"

    "TEST: Checking last Windows Update installation date"
    "DESC: If the machine isn't updated on a regular basis, we might be able to use public exploits."
    $Results = Invoke-WindowsUpdateCheck 
    #$Results | Format-List 

    Write-Host "`n"

    "TEST: Checking local admin group"
    "DESC: Which user could we target next?"
    $Results = Invoke-LocalAdminGroupCheck
    #$Results | Format-List 
    
    Write-Host "`n"

    "TEST: Checking for AlwaysInstallElevated registry key"
    "DESC: "
    $Results = Invoke-RegistryAlwaysInstallElevatedCheck
    #$Results | Format-List 
    
    Write-Host "`n"

    "TEST: Checking system startup history"
    "DESC: Some exploits may require a reboot (e.g.: DLL Hijacking) so this information can be useful."
    $Results = Invoke-SystemStartupHistoryCheck
    #$Results | Format-List 

    Write-Host "`n"

    "TEST: Checking file system drives"
    "DESC: It's quite common to see program folders configured with weak permissions on additional partitions."
    $Results = Invoke-SystemDrivesCheck
    #$Results | Format-List 

    Write-Host "`n"

}
#endregion Main
